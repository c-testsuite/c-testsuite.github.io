    <html>
    <header><title>9cc-x86_64 report</title></header>
    <body>
<h2>9cc-x86_64</h2>
<br>
9cc-x86_64 version:
<br>
882e4b2dd827ef4f00f801f45e78d8031641c067
<br>
test date: 2019-05-15
<h3>single-exec</h3>
<br>
<pre>
Test summary:

pass 50
fail 170
skip 0
---------
total 220

not ok ./tests/single-exec/00010.c
  int
  main()
  {
  	start:
  		goto next;
  		return 1;
  	success:
  		return 0;
  	next:
  	foo:
  		goto success;
  		return 1;
  }
  +9cc ./tests/single-exec/00010.c
  error at ./tests/single-exec/00010.c:4:2
  
  	start:
  	^
  
  undefined variable
  +exit 1
not ok ./tests/single-exec/00019.c
  int
  main()
  {
  	struct S { struct S *p; int x; } s;
  	
  	s.x = 0;
  	s.p = &amp;s;
  	return s.p-&gt;p-&gt;p-&gt;p-&gt;p-&gt;x;
  }
  
  +9cc ./tests/single-exec/00019.c
  error at ./tests/single-exec/00019.c:8:12
  
  	return s.p-&gt;p-&gt;p-&gt;p-&gt;p-&gt;x;
  	          ^
  
  incomplete type
  +exit 1
not ok ./tests/single-exec/00020.c
  int
  main()
  {
  	int x, *p, **pp;
  	
  	x = 0;
  	p = &amp;x;
  	pp = &amp;p;
  	return **pp;
  }
  +9cc ./tests/single-exec/00020.c
  error at ./tests/single-exec/00020.c:4:7
  
  	int x, *p, **pp;
  	     ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00021.c
  int
  foo(int a, int b)
  {
  	return 2 + a - b;
  }
  
  int
  main()
  {
  	return foo(1, 3);
  }
  
  +9cc ./tests/single-exec/00021.c
  Segmentation fault (core dumped)
  +exit 1
not ok ./tests/single-exec/00025.c
  int strlen(char *);
  
  int
  main()
  {
  	char *p;
  	
  	p = &quot;hello&quot;;
  	return strlen(p) - 5;
  }
  +9cc ./tests/single-exec/00025.c
  error at ./tests/single-exec/00025.c:1:18
  
  int strlen(char *);
                   ^
  
  bad direct-declarator
  +exit 1
not ok ./tests/single-exec/00032.c
  int
  main()
  {
  	int arr[2];
  	int *p;
  	
  	arr[0] = 2;
  	arr[1] = 3;
  	p = &amp;arr[0];
  	if(*(p++) != 2)
  		return 1;
  	if(*(p++) != 3)
  		return 2;
  	
  	p = &amp;arr[1];
  	if(*(p--) != 3)
  		return 1;
  	if(*(p--) != 2)
  		return 2;
  		
  	p = &amp;arr[0];
  	if(*(++p) != 3)
  		return 1;
  	
  	p = &amp;arr[1];
  	if(*(--p) != 2)
  		return 1;
  
  	return 0;
  }
  +9cc ./tests/single-exec/00032.c
  +gcc -o ./tests/single-exec/00032.c.bin ./tests/single-exec/00032.c.s
  +./tests/single-exec/00032.c.bin
  +exit 1
not ok ./tests/single-exec/00037.c
  int
  main()
  {
  	int x[2];
  	int *p;
  	
  	x[1] = 7;
  	p = &amp;x[0];
  	p = p + 1;
  	
  	if(*p != 7)
  		return 1;
  	if(&amp;x[1] - &amp;x[0] != 1)
  		return 1;
  	
  	return 0;
  }
  +9cc ./tests/single-exec/00037.c
  error at ./tests/single-exec/00037.c:13:11
  
  	if(&amp;x[1] - &amp;x[0] != 1)
  	         ^
  
  not an integer
  +exit 1
not ok ./tests/single-exec/00038.c
  int
  main()
  {
  	int x, *p;
  
  	if (sizeof(0) &lt; 2)
  		return 1;
  	if (sizeof 0 &lt; 2)
  		return 1;
  	if (sizeof(char) &lt; 1)
  		return 1;
  	if (sizeof(int) - 2 &lt; 0)
  		return 1;
  	if (sizeof(&amp;x) != sizeof p)
  		return 1;
  	return 0;
  }
  +9cc ./tests/single-exec/00038.c
  error at ./tests/single-exec/00038.c:4:7
  
  	int x, *p;
  	     ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00039.c
  int
  main()
  {
  	void *p;
  	int x;
  	
  	x = 2;
  	p = &amp;x;
  	
  	if(*((int*)p) != 2)
  		return 1;
  	return 0;
  }
  +9cc ./tests/single-exec/00039.c
  error at ./tests/single-exec/00039.c:10:8
  
  	if(*((int*)p) != 2)
  	      ^
  
  primary expression expected
  +exit 1
not ok ./tests/single-exec/00040.c
  #include &lt;stdlib.h&gt;
  
  int N;
  int *t;
  
  int
  chk(int x, int y)
  {
          int i;
          int r;
  
          for (r=i=0; i&lt;8; i++) {
                  r = r + t[x + 8*i];
                  r = r + t[i + 8*y];
                  if (x+i &lt; 8 &amp; y+i &lt; 8)
                          r = r + t[x+i + 8*(y+i)];
                  if (x+i &lt; 8 &amp; y-i &gt;= 0)
                          r = r + t[x+i + 8*(y-i)];
                  if (x-i &gt;= 0 &amp; y+i &lt; 8)
                          r = r + t[x-i + 8*(y+i)];
                  if (x-i &gt;= 0 &amp; y-i &gt;= 0)
                          r = r + t[x-i + 8*(y-i)];
          }
          return r;
  }
  
  int
  go(int n, int x, int y)
  {
          if (n == 8) {
                  N++;
                  return 0;
          }
          for (; y&lt;8; y++) {
                  for (; x&lt;8; x++)
                          if (chk(x, y) == 0) {
                                  t[x + 8*y]++;
                                  go(n+1, x, y);
                                  t[x + 8*y]--;
                          }
                  x = 0;
          }
  	return 0;
  }
  
  int
  main()
  {
          t = calloc(64, sizeof(int));
          go(0, 0, 0);
          if(N != 92)
          	return 1;
          return 0;
  }
  
  +9cc ./tests/single-exec/00040.c
  error at ./tests/single-exec/00040.c:1:10
  
  #include &lt;stdlib.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00042.c
  int
  main()
  {
  	union { int a; int b; } u;
  	u.a = 1;
  	u.b = 3;
  	
  	if (u.a != 3 || u.b != 3)
  		return 1;
  	return 0;
  }
  +9cc ./tests/single-exec/00042.c
  error at ./tests/single-exec/00042.c:4:2
  
  	union { int a; int b; } u;
  	^
  
  undefined variable
  +exit 1
not ok ./tests/single-exec/00043.c
  struct s {
      int x;
      struct {
          int y;
          int z;
      } nest;
  };
  
  int
  main() {
      struct s v;
      v.x = 1;
      v.nest.y = 2;
      v.nest.z = 3;
      if (v.x + v.nest.y + v.nest.z != 6)
          return 1;
      return 0;
  }
  
  +9cc ./tests/single-exec/00043.c
  error at ./tests/single-exec/00043.c:7:2
  
  };
   ^
  
  identifier expected
  +exit 1
not ok ./tests/single-exec/00044.c
  struct T;
  
  struct T {
  	int x;
  };
  
  int
  main()
  {
  	struct T v;
  	{ struct T { int z; }; }
  	v.x = 2;
  	if(v.x != 2)
  		return 1;
  	return 0;
  }
  +9cc ./tests/single-exec/00044.c
  error at ./tests/single-exec/00044.c:1:9
  
  struct T;
          ^
  
  identifier expected
  +exit 1
not ok ./tests/single-exec/00045.c
  int x = 5;
  long y = 6;
  int *p = &amp;x;
  
  int
  main()
  {
  	if (x != 5) 
  		return 1;
  	if (y != 6)
  		return 2;
  	if (*p != 5)
  		return 3;
  	return 0;
  }
  
  +9cc ./tests/single-exec/00045.c
  error at ./tests/single-exec/00045.c:1:7
  
  int x = 5;
        ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00046.c
  typedef struct {
  	int a;
  	union {
  		int b1;
  		int b2;
  	};
  	struct { union { struct { int c; }; }; };
  	struct {
  		int d;
  	};
  } s;
  
  int
  main()
  {
  	s v;
  	
  	v.a = 1;
  	v.b1 = 2;
  	v.c = 3;
  	v.d = 4;
  	
  	if (v.a != 1)
  		return 1;
  	if (v.b1 != 2 &amp;&amp; v.b2 != 2)
  		return 2;
  	if (v.c != 3)
  		return 3;
  	if (v.d != 4)
  		return 4;
  	
  	return 0;
  }
  +9cc ./tests/single-exec/00046.c
  Segmentation fault (core dumped)
  +exit 1
not ok ./tests/single-exec/00047.c
  struct { int a; int b; int c; } s = {1, 2, 3};
  
  int
  main()
  {
  	if (s.a != 1)
  		return 1;
  	if (s.b != 2)
  		return 2;
  	if (s.c != 3)
  		return 3;
  
  	return 0;
  }
  +9cc ./tests/single-exec/00047.c
  error at ./tests/single-exec/00047.c:1:35
  
  struct { int a; int b; int c; } s = {1, 2, 3};
                                    ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00048.c
  struct S {int a; int b;};
  struct S s = { .b = 2, .a = 1};
  
  int
  main()
  {
  	if(s.a != 1)
  		return 1;
  	if(s.b != 2)
  		return 2;
  	return 0;
  }
  +9cc ./tests/single-exec/00048.c
  error at ./tests/single-exec/00048.c:1:25
  
  struct S {int a; int b;};
                          ^
  
  identifier expected
  +exit 1
not ok ./tests/single-exec/00049.c
  int x = 10;
  
  struct S {int a; int *p;};
  struct S s = { .p = &amp;x, .a = 1};
  
  int
  main()
  {
  	if(s.a != 1)
  		return 1;
  	if(*s.p != 10)
  		return 2;
  	return 0;
  }
  +9cc ./tests/single-exec/00049.c
  error at ./tests/single-exec/00049.c:1:7
  
  int x = 10;
        ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00050.c
  struct S1 {
  	int a;
  	int b;
  };
  
  struct S2 {
  	int a;
  	int b;
  	union {
  		int c;
  		int d;
  	};
  	struct S1 s;
  };
  
  struct S2 v = {1, 2, 3, {4, 5}};
  
  int
  main()
  {
  	if(v.a != 1)
  		return 1;
  	if(v.b != 2)
  		return 2;
  	if(v.c != 3 || v.d != 3)
  		return 3;
  	if(v.s.a != 4)
  		return 4;
  	if(v.s.b != 5)
  		return 5;
  	
  	return 0;
  }
  +9cc ./tests/single-exec/00050.c
  error at ./tests/single-exec/00050.c:4:2
  
  };
   ^
  
  identifier expected
  +exit 1
not ok ./tests/single-exec/00051.c
  int x = 0;
  
  int
  main()
  {
  	switch(x)
  		case 0:
  			;
  	switch(x)
  		case 0:
  			switch(x) {
  				case 0:
  					goto next;
  				default:
  					return 1;
  			}
  	return 1;
  	next:
  	switch(x)
  		case 1:
  			return 1;
  	switch(x) {
  		{
  			x = 1 + 1;
  			foo:
  			case 1:
  				return 1;
  		}
  	}
  	switch(x) {
  		case 0:
  			return x;
  		case 1:
  			return 1;
  		default:
  			return 1;
  	}
  }
  +9cc ./tests/single-exec/00051.c
  error at ./tests/single-exec/00051.c:1:7
  
  int x = 0;
        ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00052.c
  int
  main()
  {
  	struct T { int x; };
  	{
  		struct T s;
  		s.x = 0;
  		return s.x;
  	}
  }
  +9cc ./tests/single-exec/00052.c
  error at ./tests/single-exec/00052.c:4:21
  
  	struct T { int x; };
  	                   ^
  
  bad direct-declarator
  +exit 1
not ok ./tests/single-exec/00054.c
  enum E {
  	x,
  	y,
  	z,
  };
  
  int
  main()
  {
  	enum E e;
  
  	if(x != 0)
  		return 1;
  	if(y != 1)
  		return 2;
  	if(z != 2)
  		return 3;
  	
  	e = x;
  	return e;
  }
  
  +9cc ./tests/single-exec/00054.c
  error at ./tests/single-exec/00054.c:1:6
  
  enum E {
       ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00055.c
  enum E {
  	x,
  	y = 2,
  	z,
  };
  
  int
  main()
  {
  	enum E e;
  
  	if(x != 0)
  		return 1;
  	if(y != 2)
  		return 2;
  	if(z != 3)
  		return 3;
  	
  	e = x;
  	return e;
  }
  
  +9cc ./tests/single-exec/00055.c
  error at ./tests/single-exec/00055.c:1:6
  
  enum E {
       ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00056.c
  #include &lt;stdio.h&gt;
  
  int main() 
  {
     int a;
     a = 42;
     printf(&quot;%d\n&quot;, a);
  
     int b = 64;
     printf(&quot;%d\n&quot;, b);
  
     int c = 12, d = 34;
     printf(&quot;%d, %d\n&quot;, c, d);
  
     return 0;
  }
  
  // vim: set expandtab ts=4 sw=3 sts=3 tw=80 :
  +9cc ./tests/single-exec/00056.c
  error at ./tests/single-exec/00056.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00057.c
  int
  main()
  {
  	char a[16], b[16];
  	
  	if(sizeof(a) != sizeof(b))
  		return 1;
  	return 0;
  }
  +9cc ./tests/single-exec/00057.c
  error at ./tests/single-exec/00057.c:4:12
  
  	char a[16], b[16];
  	          ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00062.c
  #ifdef FOO
  	XXX
  #ifdef BAR
  	XXX
  #endif
  	XXX
  #endif
  
  #define FOO 1
  
  #ifdef FOO
  
  #ifdef FOO
  int x = 0;
  #endif
  
  int
  main()
  {
  	return x;
  }
  #endif
  
  
  
  +9cc ./tests/single-exec/00062.c
  error at ./tests/single-exec/00062.c:1:2
  
  #ifdef FOO
   ^
  
  unknown directive
  +exit 1
not ok ./tests/single-exec/00063.c
  #define BAR 0
  #ifdef BAR
  	#ifdef FOO
  		XXX
  		#ifdef FOO
  			XXX
  		#endif
  	#else
  		#define FOO
  		#ifdef FOO
  			int x = BAR;
  		#endif
  	#endif
  #endif
  
  int
  main()
  {
  	return BAR;
  }
  +9cc ./tests/single-exec/00063.c
  error at ./tests/single-exec/00063.c:2:2
  
  #ifdef BAR
   ^
  
  unknown directive
  +exit 1
not ok ./tests/single-exec/00066.c
  #define A 3
  #define FOO(X,Y,Z) X + Y + Z
  #define SEMI ;
  
  int
  main()
  {
  	if(FOO(1, 2, A) != 6)
  		return 1 SEMI
  	return FOO(0,0,0);
  }
  +9cc ./tests/single-exec/00066.c
  error at ./tests/single-exec/00066.c:8:15
  
  	if(FOO(1, 2, A) != 6)
  	             ^
  
  undefined variable
  +exit 1
not ok ./tests/single-exec/00067.c
  #if 1
  int x = 0;
  #endif
  
  #if 0
  int x = 1;
  #if 1
   X
  #endif
  #ifndef AAA
   X
  #endif
  #endif
  
  int main()
  {
  	return x;
  }
  +9cc ./tests/single-exec/00067.c
  error at ./tests/single-exec/00067.c:1:2
  
  #if 1
   ^
  
  identifier expected
  +exit 1
not ok ./tests/single-exec/00068.c
  #if 0
  X
  #elif 1
  int x = 0;
  #else
  X
  #endif
  
  int
  main()
  {
  	return x;
  }
  +9cc ./tests/single-exec/00068.c
  error at ./tests/single-exec/00068.c:1:2
  
  #if 0
   ^
  
  identifier expected
  +exit 1
not ok ./tests/single-exec/00069.c
  #if 0
  X
  #elif 0
  X
  #elif 1
  int x = 0;
  #endif
  
  int
  main()
  {
  	return x;
  }
  +9cc ./tests/single-exec/00069.c
  error at ./tests/single-exec/00069.c:1:2
  
  #if 0
   ^
  
  identifier expected
  +exit 1
not ok ./tests/single-exec/00070.c
  #ifndef DEF
  int x = 0;
  #endif
  
  #define DEF
  
  #ifndef DEF
  X
  #endif
  
  int
  main()
  {
  	return x;
  }
  +9cc ./tests/single-exec/00070.c
  error at ./tests/single-exec/00070.c:1:2
  
  #ifndef DEF
   ^
  
  unknown directive
  +exit 1
not ok ./tests/single-exec/00071.c
  #define X 1
  #undef X
  
  #ifdef X
  FAIL
  #endif
  
  int
  main()
  {
  	return 0;
  }
  +9cc ./tests/single-exec/00071.c
  error at ./tests/single-exec/00071.c:2:2
  
  #undef X
   ^
  
  unknown directive
  +exit 1
not ok ./tests/single-exec/00073.c
  int
  main()
  {
  	int arr[2];
  	int *p;
  	
  	p = &amp;arr[1];
  	p -= 1;
  	*p = 123;
  	
  	if(arr[0] != 123)
  		return 1;
  	return 0;
  }
  +9cc ./tests/single-exec/00073.c
  +gcc -o ./tests/single-exec/00073.c.bin ./tests/single-exec/00073.c.s
  +./tests/single-exec/00073.c.bin
  +exit 1
not ok ./tests/single-exec/00074.c
  #if defined X
  X
  #endif
  
  #if defined(X)
  X
  #endif
  
  #if X
  X
  #endif
  
  #define X 0
  
  #if X
  X
  #endif
  
  #if defined(X)
  int x = 0;
  #endif
  
  #undef X
  #define X 1
  
  #if X
  int
  main()
  {
  	return 0;
  }
  #endif
  +9cc ./tests/single-exec/00074.c
  error at ./tests/single-exec/00074.c:1:2
  
  #if defined X
   ^
  
  identifier expected
  +exit 1
not ok ./tests/single-exec/00075.c
  #if (-2) != -2
  #error fail
  #endif
  
  #if (0 || 0) != 0
  #error fail
  #endif
  
  #if (1 || 0) != 1
  #error fail
  #endif
  
  #if (1 || 1) != 1
  #error fail
  #endif
  
  #if (0 &amp;&amp; 0) != 0
  #error fail
  #endif
  
  #if (1 &amp;&amp; 0) != 0
  #error fail
  #endif
  
  #if (0 &amp;&amp; 1) != 0
  #error fail
  #endif
  
  #if (1 &amp;&amp; 1) != 1
  #error fail
  #endif
  
  #if (0xf0 | 1) != 0xf1
  #error fail
  #endif
  
  #if (0xf0 &amp; 1) != 0
  #error fail
  #endif
  
  #if (0xf0 &amp; 0x1f) != 0x10
  #error fail
  #endif
  
  #if (1 ^ 1) != 0
  #error fail
  #endif
  
  #if (1 == 1) != 1
  #error fail
  #endif
  
  #if (1 == 0) != 0
  #error fail
  #endif
  
  #if (1 != 1) != 0
  #error fail
  #endif
  
  #if (0 != 1) != 1
  #error fail
  #endif
  
  #if (0 &gt; 1) != 0
  #error fail
  #endif
  
  #if (0 &lt; 1) != 1
  #error fail
  #endif
  
  #if (0 &gt; -1) != 1
  #error fail
  #endif
  
  #if (0 &lt; -1) != 0
  #error fail
  #endif
  
  #if (0 &gt;= 1) != 0
  #error fail
  #endif
  
  #if (0 &lt;= 1) != 1
  #error fail
  #endif
  
  #if (0 &gt;= -1) != 1
  #error fail
  #endif
  
  #if (0 &lt;= -1) != 0
  #error fail
  #endif
  
  #if (0 &lt; 0) != 0
  #error fail
  #endif
  
  #if (0 &lt;= 0) != 1
  #error fail
  #endif
  
  #if (0 &gt; 0) != 0
  #error fail
  #endif
  
  #if (0 &gt;= 0) != 1
  #error fail
  #endif
  
  #if (1 &lt;&lt; 1) != 2
  #error fail
  #endif
  
  #if (2 &gt;&gt; 1) != 1
  #error fail
  #endif
  
  #if (2 + 1) != 3
  #error fail
  #endif
  
  #if (2 - 3) != -1
  #error fail
  #endif
  
  #if (2 * 3) != 6
  #error fail
  #endif
  
  #if (6 / 3) != 2
  #error fail
  #endif
  
  #if (7 % 3) != 1
  #error fail
  #endif
  
  #if (2+2*3+2) != 10
  #error fail
  #endif
  
  #if ((2+2)*(3+2)) != 20
  #error fail
  #endif
  
  #if (2 + 2 + 2 + 2 == 2 + 2 * 3) != 1
  #error fail
  #endif
  
  #if (0 ? 1 : 3) != 3
  #error fail
  #endif
  
  #if (1 ? 3 : 1) != 3
  #error fail
  #endif
  
  int
  main()
  {
  	return 0;
  }
  
  +9cc ./tests/single-exec/00075.c
  error at ./tests/single-exec/00075.c:1:2
  
  #if (-2) != -2
   ^
  
  identifier expected
  +exit 1
not ok ./tests/single-exec/00077.c
  int
  foo(int x[100])
  {
  	int y[100];
  	int *p;
  	
  	y[0] = 2000;
  	
  	if(x[0] != 1000)
  	{
  		return 1;
  	}
  	
  	p = x;
  	
  	if(p[0] != 1000)
  	{
  		return 2;
  	}
  	
  	p = y;
  	
  	if(p[0] != 2000)
  	{
  		return 3;
  	}
  	
  	if(sizeof(x) != sizeof(void*))
  	{
  		return 4;
  	}
  	
  	if(sizeof(y) &lt;= sizeof(x))
  	{
  		return 5;
  	}
  	
  	return 0;
  }
  
  int
  main()
  {
  	int x[100];
  	x[0] = 1000;
  	
  	return foo(x);
  }
  +9cc ./tests/single-exec/00077.c
  Segmentation fault (core dumped)
  +exit 1
not ok ./tests/single-exec/00078.c
  int
  f1(char *p)
  {
  	return *p+1;
  }
  
  int
  main()
  {
  	char s = 1;
  	int v[1000];
  	int f1(char *);
  
  	if (f1(&amp;s) != 2)
  		return 1;
  	return 0;
  }
  +9cc ./tests/single-exec/00078.c
  Segmentation fault (core dumped)
  +exit 1
not ok ./tests/single-exec/00079.c
  #define x(y) ((y) + 1)
  
  int
  main()
  {
  	int x;
  	int y;
  	
  	y = 0;
  	x = x(y);
  	
  	if(x != 1)
  		return 1;
  	
  	return 0;
  }
  
  +9cc ./tests/single-exec/00079.c
  error at ./tests/single-exec/00079.c:6:7
  
  	int x;
  	     ^
  
  comma expected
  +exit 1
not ok ./tests/single-exec/00080.c
  void
  voidfn()
  {
      return;
  }
  
  int
  main()
  {
      voidfn();
      return 0;
  }
  +9cc ./tests/single-exec/00080.c
  error at ./tests/single-exec/00080.c:4:11
  
      return;
            ^
  
  primary expression expected
  +exit 1
not ok ./tests/single-exec/00081.c
  int
  main()
  {
  	long long x;
  	
  	x = 0;
  	x = x + 1;
  	if (x != 1)
  		return 1;
  	return 0;
  }
  +9cc ./tests/single-exec/00081.c
  error at ./tests/single-exec/00081.c:4:2
  
  	long long x;
  	^
  
  undefined variable
  +exit 1
not ok ./tests/single-exec/00082.c
  int
  main()
  {
  	unsigned long long x;
  	
  	x = 0;
  	x = x + 1;
  	if (x != 1)
  		return 1;
  	return 0;
  }
  +9cc ./tests/single-exec/00082.c
  error at ./tests/single-exec/00082.c:4:2
  
  	unsigned long long x;
  	^
  
  undefined variable
  +exit 1
not ok ./tests/single-exec/00083.c
  #define CALL(FUN, ...) FUN(__VA_ARGS__)
  
  int
  none()
  {
  	return 0;
  }
  
  int
  one(int a)
  {
  	if (a != 1)
  		return 1;
  	
  	return 0;
  }
  
  int
  two(int a, int b)
  {
  	if (a != 1)
  		return 1;
  	if (b != 2)
  		return 1;
  	
  	return 0;
  }
  
  int
  three(int a, int b, int c)
  {
  	if (a != 1)
  		return 1;
  	if (b != 2)
  		return 1;
  	if (c != 3)
  		return 1;
  	
  	return 0;
  }
  
  int
  main()
  {
  	if (CALL(none))
  		return 1;
  	if (CALL(one, 1))
  		return 2;
  	if (CALL(two, 1, 2))
  		return 3;
  	if (CALL(three, 1, 2, 3))
  		return 4;
  	
  	return 0;
  }
  +9cc ./tests/single-exec/00083.c
  error at ./tests/single-exec/00083.c:1:19
  
  #define CALL(FUN, ...) FUN(__VA_ARGS__)
                    ^
  
  parameter name expected
  +exit 1
not ok ./tests/single-exec/00084.c
  #define ARGS(...) __VA_ARGS__
  
  int
  none()
  {
  	return 0;
  }
  
  int
  one(int a)
  {
  	if (a != 1)
  		return 1;
  	
  	return 0;
  }
  
  int
  two(int a, int b)
  {
  	if (a != 1)
  		return 1;
  	if (b != 2)
  		return 1;
  	
  	return 0;
  }
  
  int
  three(int a, int b, int c)
  {
  	if (a != 1)
  		return 1;
  	if (b != 2)
  		return 1;
  	if (c != 3)
  		return 1;
  	
  	return 0;
  }
  
  int
  main()
  {
  	if (none(ARGS()))
  		return 1;
  	if (one(ARGS(1)))
  		return 2;
  	if (two(ARGS(1, 2)))
  		return 3;
  	if (three(ARGS(1, 2, 3)))
  		return 4;
  	return 0;
  }
  +9cc ./tests/single-exec/00084.c
  error at ./tests/single-exec/00084.c:1:14
  
  #define ARGS(...) __VA_ARGS__
               ^
  
  parameter name expected
  +exit 1
not ok ./tests/single-exec/00085.c
  #define ZERO_0() 0
  #define ZERO_1(A) 0
  #define ZERO_2(A, B) 0
  #define ZERO_VAR(...) 0
  #define ZERO_1_VAR(A, ...) 0
  
  int
  main()
  {
  	if (ZERO_0())
  		return 1;
  	if (ZERO_1(1))
  		return 1;
  	if (ZERO_2(1, 2))
  		return 1;
  	if (ZERO_VAR())
  		return 1;
  	if (ZERO_VAR(1))
  		return 1;
  	if (ZERO_VAR(1, 2))
  		return 1;
  	if (ZERO_1_VAR(1))
  		return 1;
  	if (ZERO_1_VAR(1, 2))
  		return 1;
  	if (ZERO_1_VAR(1, 2, 3))
  		return 1;
  		
  	return 0;
  }
  +9cc ./tests/single-exec/00085.c
  error at ./tests/single-exec/00085.c:4:18
  
  #define ZERO_VAR(...) 0
                   ^
  
  parameter name expected
  +exit 1
not ok ./tests/single-exec/00086.c
  int
  main()
  {
  	short x;
  	
  	x = 0;
  	x = x + 1;
  	if (x != 1)
  		return 1;
  	return 0;
  }
  +9cc ./tests/single-exec/00086.c
  error at ./tests/single-exec/00086.c:4:2
  
  	short x;
  	^
  
  undefined variable
  +exit 1
not ok ./tests/single-exec/00087.c
  struct S
  {
  	int	(*fptr)();
  };
  
  int
  foo()
  {
  	return 0;
  }
  
  int
  main()
  {
  	struct S v;
  	
  	v.fptr = foo;
  	return v.fptr();
  }
  
  +9cc ./tests/single-exec/00087.c
  error at ./tests/single-exec/00087.c:3:13
  
  	int	(*fptr)();
  	   	       ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00088.c
  int (*fptr)() = 0;
  
  
  int
  main()
  {
  	if (fptr)
  		return 1;
  	return 0;
  }
  
  +9cc ./tests/single-exec/00088.c
  error at ./tests/single-exec/00088.c:1:5
  
  int (*fptr)() = 0;
      ^
  
  identifier expected
  +exit 1
not ok ./tests/single-exec/00089.c
  int
  zero()
  {
  	return 0;
  }
  
  struct S
  {
  	int (*zerofunc)();
  } s = { &amp;zero };
  
  struct S *
  anon()
  {
  	return &amp;s;
  }
  
  typedef struct S * (*fty)();
  
  fty
  go()
  {
  	return &amp;anon;
  }
  
  int
  main()
  {
  	return go()()-&gt;zerofunc();
  }
  +9cc ./tests/single-exec/00089.c
  error at ./tests/single-exec/00089.c:9:17
  
  	int (*zerofunc)();
  	               ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00090.c
  int a[3] = {0, 1, 2};
  
  int
  main()
  {
  	if (a[0] != 0)
  		return 1;
  	if (a[1] != 1)
  		return 2;
  	if (a[2] != 2)
  		return 3;
  	
  	return 0;
  }
  +9cc ./tests/single-exec/00090.c
  error at ./tests/single-exec/00090.c:1:10
  
  int a[3] = {0, 1, 2};
           ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00091.c
  typedef struct {
  	int v;
  	int sub[2];
  } S;
  
  S a[1] = {{1, {2, 3}}};
  
  int
  main()
  {
  	if (a[0].v != 1)
  		return 1;
  	if (a[0].sub[0] != 2)
  		return 2;
  	if (a[0].sub[1] != 3)
  		return 3;
  	
  	return 0;
  }
  +9cc ./tests/single-exec/00091.c
  error at ./tests/single-exec/00091.c:6:8
  
  S a[1] = {{1, {2, 3}}};
         ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00092.c
  int a[] = {5, [2] = 2, 3};
  
  int
  main()
  {
  	if (sizeof(a) != 4*sizeof(int))
  		return 1;
  		
  	if (a[0] != 5)
  		return 2;
  	if (a[1] != 0)
  		return 3;
  	if (a[2] != 2)
  		return 4;
  	if (a[3] != 3)
  		return 5;
  	
  	return 0;
  }
  +9cc ./tests/single-exec/00092.c
  error at ./tests/single-exec/00092.c:1:9
  
  int a[] = {5, [2] = 2, 3};
          ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00093.c
  int a[] = {1, 2, 3, 4};
  
  int
  main()
  {
  	if (sizeof(a) != 4*sizeof(int))
  		return 1;
  	
  	return 0;
  }
  +9cc ./tests/single-exec/00093.c
  error at ./tests/single-exec/00093.c:1:9
  
  int a[] = {1, 2, 3, 4};
          ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00095.c
  int x;
  int x = 3;
  int x;
  
  int main();
  
  void *
  foo()
  {
  	return &amp;main;
  }
  
  int
  main()
  {
  	if (x != 3)
  		return 0;
  
  	x = 0;
  	return x;
  }
  
  +9cc ./tests/single-exec/00095.c
  error at ./tests/single-exec/00095.c:2:7
  
  int x = 3;
        ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00096.c
  int x, x = 3, x;
  
  int
  main()
  {
  	if (x != 3)
  		return 0;
  
  	x = 0;
  	return x;
  }
  
  +9cc ./tests/single-exec/00096.c
  error at ./tests/single-exec/00096.c:1:6
  
  int x, x = 3, x;
       ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00097.c
  #define NULL ((void*)0)
  #define NULL ((void*)0)
  
  #define FOO(X, Y) (X + Y + Z)
  #define FOO(X, Y) (X + Y + Z)
  
  #define BAR(X, Y, ...) (X + Y + Z)
  #define BAR(X, Y, ...) (X + Y + Z)
  
  int
  main()
  {
  	return 0;
  }
  +9cc ./tests/single-exec/00097.c
  error at ./tests/single-exec/00097.c:1:15
  
  #define NULL ((void*)0)
                ^
  
  parameter name expected
  +exit 1
not ok ./tests/single-exec/00098.c
  int
  main()
  {
  	return L&#x27;\0&#x27;;
  }
  +9cc ./tests/single-exec/00098.c
  error at ./tests/single-exec/00098.c:4:9
  
  	return L&#x27;\0&#x27;;
  	       ^
  
  undefined variable
  +exit 1
not ok ./tests/single-exec/00099.c
  
  typedef struct  { int n; } Vec;
  
  static void
  vecresize(Vec *v, int cap)
  {
  	return;
  }
  
  int main()
  {
  	return 0;
  }
  +9cc ./tests/single-exec/00099.c
  error at ./tests/single-exec/00099.c:4:8
  
  static void
         ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00100.c
  int
  foo(void)
  {
  	return 0;
  }
  
  int
  main()
  {
  	return foo();
  }
  +9cc ./tests/single-exec/00100.c
  error at ./tests/single-exec/00100.c:2:9
  
  foo(void)
          ^
  
  bad direct-declarator
  +exit 1
not ok ./tests/single-exec/00103.c
  int
  main()
  {
  	int x;
  	void *foo;
  	void **bar;
  	
  	x = 0;
  	
  	foo = (void*)&amp;x;
  	bar = &amp;foo;
  	
  	return **(int**)bar;
  }
  +9cc ./tests/single-exec/00103.c
  error at ./tests/single-exec/00103.c:10:9
  
  	foo = (void*)&amp;x;
  	       ^
  
  primary expression expected
  +exit 1
not ok ./tests/single-exec/00104.c
  #include &lt;stdint.h&gt;
  
  int
  main()
  {
  	int32_t x;
  	int64_t l;
  	
  	x = 0;
  	l = 0;
  	
  	x = ~x;
  	if (x != 0xffffffff)
  		return 1;
  	
  	l = ~l;
  	if (x != 0xffffffffffffffff)
  		return 2;
  
  	
  	return 0;
  }
  +9cc ./tests/single-exec/00104.c
  error at ./tests/single-exec/00104.c:1:10
  
  #include &lt;stdint.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00106.c
  struct S1 { int x; };
  struct S2 { struct S1 s1; };
  
  int
  main()
  {
  	struct S2 s2;
  	s2.s1.x = 1;
  	return 0;
  }
  +9cc ./tests/single-exec/00106.c
  error at ./tests/single-exec/00106.c:1:21
  
  struct S1 { int x; };
                      ^
  
  identifier expected
  +exit 1
not ok ./tests/single-exec/00107.c
  typedef int myint;
  myint x = (myint)1;
  
  int
  main(void)
  {
  	return x-1;
  }
  +9cc ./tests/single-exec/00107.c
  error at ./tests/single-exec/00107.c:2:9
  
  myint x = (myint)1;
          ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00108.c
  int foo(void);
  int foo(void);
  #define FOO 0
  
  int
  main()
  {
  	return FOO;
  }
  +9cc ./tests/single-exec/00108.c
  error at ./tests/single-exec/00108.c:1:13
  
  int foo(void);
              ^
  
  bad direct-declarator
  +exit 1
not ok ./tests/single-exec/00111.c
  int
  main()
  {
  	short s = 1;
  	long l = 1;
  
  	s -= l;
  	return s;
  }
  +9cc ./tests/single-exec/00111.c
  error at ./tests/single-exec/00111.c:4:2
  
  	short s = 1;
  	^
  
  undefined variable
  +exit 1
not ok ./tests/single-exec/00112.c
  int
  main()
  {
  	return &quot;abc&quot; == (void *)0;
  }
  +9cc ./tests/single-exec/00112.c
  error at ./tests/single-exec/00112.c:4:19
  
  	return &quot;abc&quot; == (void *)0;
  	                 ^
  
  primary expression expected
  +exit 1
not ok ./tests/single-exec/00113.c
  int
  main()
  {
  	int a = 0;
  	float f = a + 1;
  
  	return f == a;
  }
  +9cc ./tests/single-exec/00113.c
  error at ./tests/single-exec/00113.c:5:2
  
  	float f = a + 1;
  	^
  
  undefined variable
  +exit 1
not ok ./tests/single-exec/00114.c
  int main(void);
  
  int
  main()
  {
  	return 0;
  }
  +9cc ./tests/single-exec/00114.c
  error at ./tests/single-exec/00114.c:1:14
  
  int main(void);
               ^
  
  bad direct-declarator
  +exit 1
not ok ./tests/single-exec/00115.c
  #define B &quot;b&quot;
  
  char s[] = &quot;a&quot; B &quot;c&quot;;
  
  int
  main()
  {
  	if (s[0] != &#x27;a&#x27;)
  		return 1;
  	if (s[1] != &#x27;b&#x27;)
  		return 2;
  	if (s[2] != &#x27;c&#x27;)
  		return 3;
  	if (s[3] != &#x27;\0&#x27;)
  		return 4;
  	return 0;
  }
  +9cc ./tests/single-exec/00115.c
  error at ./tests/single-exec/00115.c:3:10
  
  char s[] = &quot;a&quot; B &quot;c&quot;;
           ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00116.c
  int
  f(int f)
  {
  	return f;
  }
  
  int
  main()
  {
  	return f(0);
  }
  +9cc ./tests/single-exec/00116.c
  Segmentation fault (core dumped)
  +exit 1
not ok ./tests/single-exec/00117.c
  int main()
  {
  	int x[] = { 1, 0 };
  	return x[1];
  }
  +9cc ./tests/single-exec/00117.c
  error at ./tests/single-exec/00117.c:3:12
  
  	int x[] = { 1, 0 };
  	          ^
  
  primary expression expected
  +exit 1
not ok ./tests/single-exec/00118.c
  int
  main()
  {
  	struct { int x; } s = { 0 };
  	return s.x;
  }
  +9cc ./tests/single-exec/00118.c
  error at ./tests/single-exec/00118.c:4:24
  
  	struct { int x; } s = { 0 };
  	                      ^
  
  primary expression expected
  +exit 1
not ok ./tests/single-exec/00119.c
  double x = 100;
  
  int
  main()
  {
  	return x &lt; 1;
  }
  +9cc ./tests/single-exec/00119.c
  error at ./tests/single-exec/00119.c:1:8
  
  double x = 100;
         ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00120.c
  struct {
  	enum { X } x;
  } s;
  
  
  int
  main()
  {
  	return X;
  }
  +9cc ./tests/single-exec/00120.c
  Segmentation fault (core dumped)
  +exit 1
not ok ./tests/single-exec/00121.c
  int f(int a), g(int a), a;
  
  
  int
  main()
  {
  	return f(1) - g(1);
  }
  
  int
  f(int a)
  {
  	return a;
  }
  
  int
  g(int a)
  {
  	return a;
  }
  +9cc ./tests/single-exec/00121.c
  Segmentation fault (core dumped)
  +exit 1
not ok ./tests/single-exec/00123.c
  double x = 100.0;
  
  int
  main()
  {
  	return x &lt; 1;
  }
  +9cc ./tests/single-exec/00123.c
  error at ./tests/single-exec/00123.c:1:8
  
  double x = 100.0;
         ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00124.c
  int
  f2(int c, int b)
  {
  	return c - b;
  }
  
  int (*
  f1(int a, int b))(int c, int b)
  {
  	if (a != b)
  		return f2;
  	return 0;
  }
  
  int
  main()
  {
  	int (* (*p)(int a, int b))(int c, int d) = f1;
  
  
  	return (*(*p)(0, 2))(2, 2);
  }
  +9cc ./tests/single-exec/00124.c
  Segmentation fault (core dumped)
  +exit 1
not ok ./tests/single-exec/00125.c
  #include &lt;stdio.h&gt;
  
  int
  main(void)
  {
  	printf(&quot;hello world\n&quot;);
  	return 0;
  }
  +9cc ./tests/single-exec/00125.c
  error at ./tests/single-exec/00125.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00128.c
  
  int a;
  unsigned b;
  char c;
  signed char d;
  unsigned char e;
  long f;
  unsigned long g;
  long long h;
  unsigned long long i;
  short j;
  unsigned short k;
  
  int
  main(void)
  {
  	a = b;
  	a = c;
  	a = d;
  	a = e;
  	a = f;
  	a = g;
  	a = h;
  	a = i;
  	a = j;
  	a = k;
  
  	b = a;
  	b = c;
  	b = d;
  	b = e;
  	b = f;
  	b = g;
  	b = h;
  	b = i;
  	b = j;
  	b = k;
  
  	c = a;
  	c = b;
  	c = d;
  	c = e;
  	c = f;
  	c = g;
  	c = h;
  	c = i;
  	c = j;
  	c = k;
  
  	d = a;
  	d = b;
  	d = c;
  	d = e;
  	d = f;
  	d = g;
  	d = h;
  	d = i;
  	d = j;
  	d = k;
  
  	e = a;
  	e = b;
  	e = c;
  	e = d;
  	e = f;
  	e = g;
  	e = h;
  	e = i;
  	e = j;
  	e = k;
  
  	f = a;
  	f = b;
  	f = c;
  	f = d;
  	f = e;
  	f = g;
  	f = h;
  	f = i;
  	f = j;
  	f = k;
  
  	g = a;
  	g = b;
  	g = c;
  	g = d;
  	g = e;
  	g = f;
  	g = h;
  	g = i;
  	g = j;
  	g = k;
  
  	h = a;
  	h = b;
  	h = c;
  	h = d;
  	h = e;
  	h = f;
  	h = g;
  	h = i;
  	h = j;
  	h = k;
  
  	i = a;
  	i = b;
  	i = c;
  	i = d;
  	i = e;
  	i = f;
  	i = g;
  	i = h;
  	i = j;
  	i = k;
  
  	j = a;
  	j = b;
  	j = c;
  	j = d;
  	j = e;
  	j = f;
  	j = g;
  	j = h;
  	j = i;
  	j = k;
  
  	k = a;
  	k = b;
  	k = c;
  	k = d;
  	k = e;
  	k = f;
  	k = g;
  	k = h;
  	k = j;
  	k = i;
  
  	return 0;
  }
  +9cc ./tests/single-exec/00128.c
  error at ./tests/single-exec/00128.c:3:10
  
  unsigned b;
           ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00129.c
  typedef struct s s;
  
  struct s {
  	struct s1 {
  		int s;
  		struct s2 {
  			int s;
  		} s1;
  	} s;
  } s2;
  
  #define s s
  
  int
  main(void)
  {
  #undef s
  	goto s;
  	struct s s;
  		{
  			int s;
  			return s;
  		}
  	return s.s.s + s.s.s1.s;
  	s:
  		{
  			return 0;
  		}
  	return 1;
  }
  +9cc ./tests/single-exec/00129.c
  error at ./tests/single-exec/00129.c:17:2
  
  #undef s
   ^
  
  unknown directive
  +exit 1
not ok ./tests/single-exec/00130.c
  int
  main()
  {
  	char arr[2][4], (*p)[4], *q;
  	int v[4];
  
  	p = arr;
  	q = &amp;arr[1][3];
  	arr[1][3] = 2;
  	v[0] = 2;
  
  	if (arr[1][3] != 2)
  		return 1;
  	if (p[1][3] != 2)
  		return 1;
  	if (*q != 2)
  		return 1;
  	if (*v != 2)
  		return 1;
  
  	return 0;
  }
  +9cc ./tests/single-exec/00130.c
  error at ./tests/single-exec/00130.c:4:16
  
  	char arr[2][4], (*p)[4], *q;
  	              ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00131.c
  #include &lt;stdio.h&gt;
  
  int main() 
  {
     printf(&quot;Hello\n&quot;);
     printf(&quot;Hello\n&quot;); /* this is a comment */ printf(&quot;Hello\n&quot;);
     printf(&quot;Hello\n&quot;);
     // this is also a comment sayhello();
     printf(&quot;Hello\n&quot;);
  
     return 0;
  }
  
  // vim: set expandtab ts=4 sw=3 sts=3 tw=80 :
  +9cc ./tests/single-exec/00131.c
  error at ./tests/single-exec/00131.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00132.c
  #include &lt;stdio.h&gt;
  
  int main() 
  {
     printf(&quot;Hello world\n&quot;);
  
     int Count;
     for (Count = -5; Count &lt;= 5; Count++)
        printf(&quot;Count = %d\n&quot;, Count);
  
     printf(&quot;String &#x27;hello&#x27;, &#x27;there&#x27; is &#x27;%s&#x27;, &#x27;%s&#x27;\n&quot;, &quot;hello&quot;, &quot;there&quot;);
     printf(&quot;Character &#x27;A&#x27; is &#x27;%c&#x27;\n&quot;, 65);
     printf(&quot;Character &#x27;a&#x27; is &#x27;%c&#x27;\n&quot;, &#x27;a&#x27;);
  
     return 0;
  }
  
  // vim: set expandtab ts=4 sw=3 sts=3 tw=80 :
  +9cc ./tests/single-exec/00132.c
  error at ./tests/single-exec/00132.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00133.c
  int main(void)
  {
  	int i;
  	unsigned u;
  
  	i = 1;
  	i = -1;
  	i = -1l;
  	i = -1u;
  	i = -1ll;
  	i = 32766 + 1 &amp; 3;
  	i = (int) 32768 &lt; 0;
  	i = -1u &lt; 0;
  
  	u = 1;
  	u = -1;
  	u = -1l;
  	u = -1u;
  	u = -1ll;
  	u = (unsigned) 32768 &lt; 0;
  	u = 32766 + 1 &amp; 3;
  	u = -1u &lt; 0;
  	return 0;
  }
  +9cc ./tests/single-exec/00133.c
  error at ./tests/single-exec/00133.c:1:14
  
  int main(void)
               ^
  
  bad direct-declarator
  +exit 1
not ok ./tests/single-exec/00134.c
  int
  main(void)
  {
  	long i;
  	unsigned long u;
  
  	i = 1;
  	i = -1;
  	i = -1l;
  	i = -1u;
  	i = -1ll;
  	i = (1ll &lt;&lt; 32) - 1 &amp; 3;
  	i = (long) ((1ll &lt;&lt; 32) - 1) &lt; 0;
  	i = -1u &lt; 0;
  
  	u = 1;
  	u = -1;
  	u = -1l;
  	u = -1u;
  	u = -1ll;
  	u = (1ll &lt;&lt; 32) - 1 &amp; 3;
  	u = (long) ((1ll &lt;&lt; 32) - 1) &lt; 0;
  	u = -1u &lt; 0;
  	return 0;
  }
  +9cc ./tests/single-exec/00134.c
  error at ./tests/single-exec/00134.c:2:10
  
  main(void)
           ^
  
  bad direct-declarator
  +exit 1
not ok ./tests/single-exec/00135.c
  int
  main(void)
  {
  	long long i;
  	unsigned long long u;
  
  	i = 1;
  	i = -1;
  	i = -1l;
  	i = -1u;
  	i = -1ll;
  	i = -1ll &amp; 3;
  	i = -1ll &lt; 0;
  
  	u = 1;
  	u = -1;
  	u = -1l;
  	u = -1u;
  	u = -1ll;
  	u = -1llu &amp; 3;
  	u = -1llu &lt; 0;
  	return 0;
  }
  +9cc ./tests/single-exec/00135.c
  error at ./tests/single-exec/00135.c:2:10
  
  main(void)
           ^
  
  bad direct-declarator
  +exit 1
not ok ./tests/single-exec/00136.c
  #define FOO
  
  #ifdef FOO
  	int a;
  	int b;
  	#undef FOO
  	#ifndef FOO
  		int c;
  		int d;
  	#else
  		int e;
  		int f;
  	#endif
  	int e;
  	int f;
  	#ifdef FOO
  		int c_;
  		int d_;
  	#else
  		int e_;
  		int f_;
  	#endif
  	int e_;
  	int f_;
  int
  main()
  {
  	return 0;
  }
  #else
  	int j;
  	int k;
  	#ifdef FOO
  		int j;
  		int k;
  	#else
  		int n;
  		int o;
  	#endif
  	int n;
  	int o;
  	#ifndef FOO
  		int r;
  		int s;
  	#else
  		int t;
  		int u;
  	#endif
  	int t;
  	int u;
  	#error bad branch
  #endif
  +9cc ./tests/single-exec/00136.c
  error at ./tests/single-exec/00136.c:3:2
  
  #ifdef FOO
   ^
  
  unknown directive
  +exit 1
not ok ./tests/single-exec/00137.c
  #define x(y) #y
  
  int
  main(void)
  {
  	char *p;
  	p = x(hello)  &quot; is better than bye&quot;;
  
  	return (*p == &#x27;h&#x27;) ? 0 : 1;
  }
  +9cc ./tests/single-exec/00137.c
  error at ./tests/single-exec/00137.c:4:10
  
  main(void)
           ^
  
  bad direct-declarator
  +exit 1
not ok ./tests/single-exec/00138.c
  #define M(x) x
  #define A(a,b) a(b)
  
  int
  main(void)
  {
  	char *a = A(M,&quot;hi&quot;);
  
  	return (a[1] == &#x27;i&#x27;) ? 0 : 1;
  }
  +9cc ./tests/single-exec/00138.c
  error at ./tests/single-exec/00138.c:5:10
  
  main(void)
           ^
  
  bad direct-declarator
  +exit 1
not ok ./tests/single-exec/00139.c
  /*
   * f(2) will expand to 2*g, which will expand to 2*f, and in this
   * moment f will not be expanded because the macro definition is
   * a function alike macro, and in this case there is no arguments.
   */
  #define f(a) a*g
  #define g f
  
  int
  main(void)
  {
          int f = 0;
  
          return f(2);
  }
  +9cc ./tests/single-exec/00139.c
  error at ./tests/single-exec/00139.c:12:15
  
          int f = 0;
                ^
  
  comma expected
  +exit 1
not ok ./tests/single-exec/00140.c
  struct foo {
  	int i, j, k;
  	char *p;
  	float v;
  };
  
  int
  f1(struct foo f, struct foo *p, int n, ...)
  {
  	if (f.i != p-&gt;i)
  		return 0;
  	return p-&gt;j + n;
  }
  
  int
  main(void)
  {
  	struct foo f;
  
  	f.i = f.j = 1;
  	f1(f, &amp;f, 2);
  	f1(f, &amp;f, 2, 1, f, &amp;f);
  
  	return 0;
  }
  +9cc ./tests/single-exec/00140.c
  error at ./tests/single-exec/00140.c:2:7
  
  	int i, j, k;
  	     ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00141.c
  #define CAT(x,y) x ## y
  #define XCAT(x,y) CAT(x,y)
  #define FOO foo
  #define BAR bar
  
  int
  main(void)
  {
  	int foo, bar, foobar;
  
  	CAT(foo,bar) = foo + bar;
  	XCAT(FOO,BAR) = foo + bar;
  	return 0;
  }
  +9cc ./tests/single-exec/00141.c
  error at ./tests/single-exec/00141.c:7:10
  
  main(void)
           ^
  
  bad direct-declarator
  +exit 1
not ok ./tests/single-exec/00142.c
  #if defined(FOO)
  int a;
  #elif !defined(FOO) &amp;&amp; defined(BAR)
  int b;
  #elif !defined(FOO) &amp;&amp; !defined(BAR)
  int c;
  #else
  int d;
  #endif
  
  int
  main(void)
  {
  	return c;
  }
  +9cc ./tests/single-exec/00142.c
  error at ./tests/single-exec/00142.c:1:2
  
  #if defined(FOO)
   ^
  
  identifier expected
  +exit 1
not ok ./tests/single-exec/00143.c
  /* Disgusting, no?  But it compiles and runs just fine.  I feel a combination of
     pride and revulsion at this discovery.  If no one&#x27;s thought of it before,
     I think I&#x27;ll name it after myself.
     It amazes me that after 10 years of writing C there are still
     little corners that I haven&#x27;t explored fully.
     - Tom Duff */
  
  int main()
  {
      int  count, n;
      short *from, *to;
      short a[39], b[39];
  
      for(n = 0; n &lt; 39; n++) {
          a[n] = n;
          b[n] = 0;
      }
      from = a;
      to = b;
      count = 39;
      n = (count + 7) / 8;
      switch (count % 8) {
      case 0: do { *to++ = *from++;
      case 7:      *to++ = *from++;
      case 6:      *to++ = *from++;
      case 5:      *to++ = *from++;
      case 4:      *to++ = *from++;
      case 3:      *to++ = *from++;
      case 2:      *to++ = *from++;
      case 1:      *to++ = *from++;
              } while (--n &gt; 0);
      }
      for(n = 0; n &lt; 39; n++)
          if(a[n] != b[n])
              return 1;
      return 0;
  }+9cc ./tests/single-exec/00143.c
  error at ./tests/single-exec/00143.c:10:15
  
      int  count, n;
                ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00144.c
  int
  main(void)
  {
  	int i, *q;
  	void *p;
  
  	i = i ? 0 : 0l;
  	p = i ? (void *) 0 : 0;
  	p = i ? 0 : (void *) 0;
  	p = i ? 0 : (const void *) 0;
  	q = i ? 0 : p;
  	q = i ? p : 0;
  	q = i ? q : 0;
  	q = i ? 0 : q;
  
  	return (int) q;
  }
  +9cc ./tests/single-exec/00144.c
  error at ./tests/single-exec/00144.c:2:10
  
  main(void)
           ^
  
  bad direct-declarator
  +exit 1
not ok ./tests/single-exec/00145.c
  #if 0 != (0 &amp;&amp; (0/0))
     #error 0 != (0 &amp;&amp; (0/0))
  #endif
  
  #if 1 != (-1 || (0/0))
     #error 1 != (-1 || (0/0))
  #endif
  
  #if 3 != (-1 ? 3 : (0/0))
     #error 3 != (-1 ? 3 : (0/0))
  #endif
  
  int
  main()
  {
  	return 0;
  }
  +9cc ./tests/single-exec/00145.c
  error at ./tests/single-exec/00145.c:1:2
  
  #if 0 != (0 &amp;&amp; (0/0))
   ^
  
  identifier expected
  +exit 1
not ok ./tests/single-exec/00146.c
  struct S { int a; int b; };
  struct S s = (struct S){1, 2};
  
  int
  main()
  {
  	if(s.a != 1)
  		return 1;
  	if(s.b != 2)
  		return 2;
  	return 0;
  }
  +9cc ./tests/single-exec/00146.c
  error at ./tests/single-exec/00146.c:1:27
  
  struct S { int a; int b; };
                            ^
  
  identifier expected
  +exit 1
not ok ./tests/single-exec/00147.c
  int arr[3] = {[2] = 2, [0] = 0, [1] = 1};
  
  int
  main()
  {
  	if(arr[0] != 0)
  		return 1;
  	if(arr[1] != 1)
  		return 2;
  	if(arr[2] != 2)
  		return 3;
  	return 0;
  }
  +9cc ./tests/single-exec/00147.c
  error at ./tests/single-exec/00147.c:1:12
  
  int arr[3] = {[2] = 2, [0] = 0, [1] = 1};
             ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00148.c
  struct S {int a; int b;};
  struct S arr[2] = {[1] = {3, 4}, [0] = {1, 2}};
  
  int
  main()
  {
  	if(arr[0].a != 1)
  		return 1;
  	if(arr[0].b != 2)
  		return 2;
  	if(arr[1].a != 3)
  		return 3;
  	if(arr[1].b != 4)
  		return 4;
  	return 0;
  }
  +9cc ./tests/single-exec/00148.c
  error at ./tests/single-exec/00148.c:1:25
  
  struct S {int a; int b;};
                          ^
  
  identifier expected
  +exit 1
not ok ./tests/single-exec/00149.c
  struct S { int a; int b; };
  struct S *s = &amp;(struct S) { 1, 2 };
  
  int
  main()
  {
  	if(s-&gt;a != 1)
  		return 1;
  	if(s-&gt;b != 2)
  		return 2;
  	return 0;
  }
  +9cc ./tests/single-exec/00149.c
  error at ./tests/single-exec/00149.c:1:27
  
  struct S { int a; int b; };
                            ^
  
  identifier expected
  +exit 1
not ok ./tests/single-exec/00150.c
  struct S1 {
  	int a;
  	int b;
  };
  struct S2 {
  	struct S1 s1;
  	struct S1 *ps1;
  	int arr[2];
  };
  struct S1 gs1 = (struct S1) {.a = 1, 2};
  struct S2 *s = &amp;(struct S2) {
  	{.b = 2, .a = 1},
  	&amp;gs1,
  	{[0] = 1,  1+1}
  };
  
  int
  main()
  {
  	if(s-&gt;s1.a != 1)
  		return 1;
  	if(s-&gt;s1.b != 2)
  		return 2;
  	if(s-&gt;ps1-&gt;a != 1)
  		return 3;
  	if(s-&gt;ps1-&gt;b != 2)
  		return 4;
  	if(s-&gt;arr[0] != 1)
  		return 5;
  	if(s-&gt;arr[1] != 2)
  		return 6;
  	return 0;
  }
  +9cc ./tests/single-exec/00150.c
  error at ./tests/single-exec/00150.c:4:2
  
  };
   ^
  
  identifier expected
  +exit 1
not ok ./tests/single-exec/00151.c
  int arr[][3][5] = {
  	{
  		{ 0, 0, 3, 5 },
  		{ 1, [3] = 6, 7 },
  	},
  	{
  		{ 1, 2 },
  		{ [4] = 7, },
  	},
  };
  
  int
  main(void)
  {
  	return !(arr[0][1][4] == arr[1][1][4]);
  }
  +9cc ./tests/single-exec/00151.c
  error at ./tests/single-exec/00151.c:1:17
  
  int arr[][3][5] = {
                  ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00152.c
  #undef  line
  #define line 1000
  
  #line line
  #if 1000 != __LINE__
  	#error &quot;  # line line&quot; not work as expected
  #endif
  
  int
  main()
  {
  	return 0;
  }
  +9cc ./tests/single-exec/00152.c
  error at ./tests/single-exec/00152.c:1:2
  
  #undef  line
   ^
  
  unknown directive
  +exit 1
not ok ./tests/single-exec/00154.c
  #include &lt;stdio.h&gt;
  
  struct fred
  {
     int boris;
     int natasha;
  };
  
  int main()
  {
     struct fred bloggs;
  
     bloggs.boris = 12;
     bloggs.natasha = 34;
  
     printf(&quot;%d\n&quot;, bloggs.boris);
     printf(&quot;%d\n&quot;, bloggs.natasha);
  
     struct fred jones[2];
     jones[0].boris = 12;
     jones[0].natasha = 34;
     jones[1].boris = 56;
     jones[1].natasha = 78;
  
     printf(&quot;%d\n&quot;, jones[0].boris);
     printf(&quot;%d\n&quot;, jones[0].natasha);
     printf(&quot;%d\n&quot;, jones[1].boris);
     printf(&quot;%d\n&quot;, jones[1].natasha);
  
     return 0;
  }
  +9cc ./tests/single-exec/00154.c
  error at ./tests/single-exec/00154.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00155.c
  
  int
  main(void)
  {
  	sizeof((int) 1);
  	return 0;
  }
  +9cc ./tests/single-exec/00155.c
  error at ./tests/single-exec/00155.c:3:10
  
  main(void)
           ^
  
  bad direct-declarator
  +exit 1
not ok ./tests/single-exec/00156.c
  #include &lt;stdio.h&gt;
  
  int main() 
  {
     int Count;
  
     for (Count = 1; Count &lt;= 10; Count++)
     {
        printf(&quot;%d\n&quot;, Count);
     }
  
     return 0;
  }
  
  // vim: set expandtab ts=4 sw=3 sts=3 tw=80 :
  +9cc ./tests/single-exec/00156.c
  error at ./tests/single-exec/00156.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00157.c
  #include &lt;stdio.h&gt;
  
  int main() 
  {
     int Count;
     int Array[10];
  
     for (Count = 1; Count &lt;= 10; Count++)
     {
        Array[Count-1] = Count * Count;
     }
  
     for (Count = 0; Count &lt; 10; Count++)
     {
        printf(&quot;%d\n&quot;, Array[Count]);
     }
  
     return 0;
  }
  
  // vim: set expandtab ts=4 sw=3 sts=3 tw=80 :
  +9cc ./tests/single-exec/00157.c
  error at ./tests/single-exec/00157.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00158.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
     int Count;
  
     for (Count = 0; Count &lt; 4; Count++)
     {
        printf(&quot;%d\n&quot;, Count);
        switch (Count)
        {
           case 1:
              printf(&quot;%d\n&quot;, 1);
              break;
  
           case 2:
              printf(&quot;%d\n&quot;, 2);
              break;
  
           default:
              printf(&quot;%d\n&quot;, 0);
              break;
        }
     }
  
     return 0;
  }
  
  // vim: set expandtab ts=4 sw=3 sts=3 tw=80 :
  +9cc ./tests/single-exec/00158.c
  error at ./tests/single-exec/00158.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00159.c
  #include &lt;stdio.h&gt;
  
  int myfunc(int x)
  {
     return x * x;
  }
  
  void vfunc(int a)
  {
     printf(&quot;a=%d\n&quot;, a);
  }
  
  void qfunc()
  {
     printf(&quot;qfunc()\n&quot;);
  }
  
  void zfunc()
  {
     ((void (*)(void))0) ();
  }
  
  int main()
  {
     printf(&quot;%d\n&quot;, myfunc(3));
     printf(&quot;%d\n&quot;, myfunc(4));
  
     vfunc(1234);
  
     qfunc();
  
     return 0;
  }
  
  // vim: set expandtab ts=4 sw=3 sts=3 tw=80 :
  +9cc ./tests/single-exec/00159.c
  error at ./tests/single-exec/00159.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00160.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
     int a;
     int p;
     int t;
  
     a = 1;
     p = 0;
     t = 0;
  
     while (a &lt; 100)
     {
        printf(&quot;%d\n&quot;, a);
        t = a;
        a = t + p;
        p = t;
     }
  
     return 0;
  }
  
  // vim: set expandtab ts=4 sw=3 sts=3 tw=80 :
  +9cc ./tests/single-exec/00160.c
  error at ./tests/single-exec/00160.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00161.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
     int a;
     int p;
     int t;
  
     a = 1;
     p = 0;
     t = 0;
  
     do
     {
        printf(&quot;%d\n&quot;, a);
        t = a;
        a = t + p;
        p = t;
     } while (a &lt; 100);
  
     return 0;
  }
  
  // vim: set expandtab ts=4 sw=3 sts=3 tw=80 :
  +9cc ./tests/single-exec/00161.c
  error at ./tests/single-exec/00161.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00162.c
  void foo(int [5]);
  void fooc(int x[const 5]);
  void foos(int x[static 5]);
  void foov(int x[volatile 5]);
  void foor(int x[restrict 5]);
  void fooc(int [const 5]);
  void foos(int [static 5]);
  void foov(int [volatile 5]);
  void foor(int [restrict 5]);
  void fooc(int (* const x));
  void foos(int *x);
  void foov(int * volatile x);
  void foor(int * restrict x);
  void fooc(int x[volatile 5])
  {
    x[3] = 42;
  #ifdef INVALID
    x = 0;
  #endif
  }
  void foovm(int x[const *]);
  void foovm(int * const x);
  #ifdef INVALID
  void wrongc(int x[3][const 4]);
  void wrongvm(int x[static *]);
  void foovm(int x[const *])
  {
    x[2] = 1;
  }
  #endif
  int main()
  {
    return 0;
  }
  +9cc ./tests/single-exec/00162.c
  error at ./tests/single-exec/00162.c:17:2
  
  #ifdef INVALID
   ^
  
  unknown directive
  +exit 1
not ok ./tests/single-exec/00163.c
  #include &lt;stdio.h&gt;
  
  struct ziggy
  {
     int a;
     int b;
     int c;
  } bolshevic;
  
  int main()
  {
     int a;
     int *b;
     int c;
  
     a = 42;
     b = &amp;a;
     printf(&quot;a = %d\n&quot;, *b);
  
     bolshevic.a = 12;
     bolshevic.b = 34;
     bolshevic.c = 56;
  
     printf(&quot;bolshevic.a = %d\n&quot;, bolshevic.a);
     printf(&quot;bolshevic.b = %d\n&quot;, bolshevic.b);
     printf(&quot;bolshevic.c = %d\n&quot;, bolshevic.c);
  
     struct ziggy *tsar = &amp;bolshevic;
  
     printf(&quot;tsar-&gt;a = %d\n&quot;, tsar-&gt;a);
     printf(&quot;tsar-&gt;b = %d\n&quot;, tsar-&gt;b);
     printf(&quot;tsar-&gt;c = %d\n&quot;, tsar-&gt;c);
  
     b = &amp;(bolshevic.b);
     printf(&quot;bolshevic.b = %d\n&quot;, *b);
  
     return 0;
  }
  
  // vim: set expandtab ts=4 sw=3 sts=3 tw=80 :
  +9cc ./tests/single-exec/00163.c
  error at ./tests/single-exec/00163.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00164.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
     int a;
     int b;
     int c;
     int d;
     int e;
     int f;
     int x;
     int y;
  
     a = 12;
     b = 34;
     c = 56;
     d = 78;
     e = 0;
     f = 1;
  
     printf(&quot;%d\n&quot;, c + d);
     printf(&quot;%d\n&quot;, (y = c + d));
     printf(&quot;%d\n&quot;, e || e &amp;&amp; f);
     printf(&quot;%d\n&quot;, e || f &amp;&amp; f);
     printf(&quot;%d\n&quot;, e &amp;&amp; e || f);
     printf(&quot;%d\n&quot;, e &amp;&amp; f || f);
     printf(&quot;%d\n&quot;, a &amp;&amp; f | f);
     printf(&quot;%d\n&quot;, a | b ^ c &amp; d);
     printf(&quot;%d, %d\n&quot;, a == a, a == b);
     printf(&quot;%d, %d\n&quot;, a != a, a != b);
     printf(&quot;%d\n&quot;, a != b &amp;&amp; c != d);
     printf(&quot;%d\n&quot;, a + b * c / f);
     printf(&quot;%d\n&quot;, a + b * c / f);
     printf(&quot;%d\n&quot;, (4 &lt;&lt; 4));
     printf(&quot;%d\n&quot;, (64 &gt;&gt; 4));
  
     return 0;
  }
  
  // vim: set expandtab ts=4 sw=3 sts=3 tw=80 :
  +9cc ./tests/single-exec/00164.c
  error at ./tests/single-exec/00164.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00165.c
  #include &lt;stdio.h&gt;
  
  #define FRED 12
  #define BLOGGS(x) (12*(x))
  
  int main()
  {
     printf(&quot;%d\n&quot;, FRED);
     printf(&quot;%d, %d, %d\n&quot;, BLOGGS(1), BLOGGS(2), BLOGGS(3));
  
     return 0;
  }
  
  // vim: set expandtab ts=4 sw=3 sts=3 tw=80 :
  +9cc ./tests/single-exec/00165.c
  error at ./tests/single-exec/00165.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00166.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
     int a = 24680;
     int b = 01234567;
     int c = 0x2468ac;
     int d = 0x2468AC;
     int e = 0b010101010101;
  
     printf(&quot;%d\n&quot;, a);
     printf(&quot;%d\n&quot;, b);
     printf(&quot;%d\n&quot;, c);
     printf(&quot;%d\n&quot;, d);
     printf(&quot;%d\n&quot;, e);
  
     return 0;
  }
  
  // vim: set expandtab ts=4 sw=3 sts=3 tw=80 :
  +9cc ./tests/single-exec/00166.c
  error at ./tests/single-exec/00166.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00167.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
     int a = 1;
  
     if (a)
        printf(&quot;a is true\n&quot;);
     else
        printf(&quot;a is false\n&quot;);
  
     int b = 0;
     if (b)
        printf(&quot;b is true\n&quot;);
     else
        printf(&quot;b is false\n&quot;);
  
     return 0;
  }
  
  // vim: set expandtab ts=4 sw=3 sts=3 tw=80 :
  +9cc ./tests/single-exec/00167.c
  error at ./tests/single-exec/00167.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00168.c
  #include &lt;stdio.h&gt;
  
  int factorial(int i) 
  {
     if (i &lt; 2)
        return i;
     else
        return i * factorial(i - 1);
  }
  
  int main()
  {
     int Count;
  
     for (Count = 1; Count &lt;= 10; Count++)
        printf(&quot;%d\n&quot;, factorial(Count));
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00168.c
  error at ./tests/single-exec/00168.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00169.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
     int x, y, z;
  
     for (x = 0; x &lt; 2; x++)
     {
        for (y = 0; y &lt; 3; y++)
        {
           for (z = 0; z &lt; 3; z++)
           {
              printf(&quot;%d %d %d\n&quot;, x, y, z);
           }
        }
     }
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00169.c
  error at ./tests/single-exec/00169.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00170.c
  #include &lt;stdio.h&gt;
  
  enum fred
  {
     a,
     b,
     c,
     d,
     e = 54,
     f = 73,
     g,
     h
  };
  
  /* All following uses of enum efoo should compile
     without warning.  While forward enums aren&#x27;t ISO C,
     it&#x27;s accepted by GCC also in strict mode, and only warned
     about with -pedantic.  This happens in the real world.  */
  /* Strict ISO C doesn&#x27;t allow this kind of forward declaration of
     enums, but GCC accepts it (and gives only pedantic warning), and
     it occurs in the wild.  */
  enum efoo;
  struct Sforward_use {
      int (*fmember) (enum efoo x);
  };
  
  extern enum efoo it_real_fn(void);
  enum efoo {
    ONE,
    TWO,
  };
  struct S2 {
    enum efoo (*f2) (void);
  };
  void should_compile(struct S2 *s)
  {
    s-&gt;f2 = it_real_fn;
  }
  
  enum efoo it_real_fn(void)
  {
    return TWO;
  }
  
  static unsigned int deref_uintptr(unsigned int *p)
  {
    return *p;
  }
  
  enum Epositive {
      epos_one, epos_two
  };
  
  int main()
  {
     enum fred frod;
     enum Epositive epos = epos_two;
  
     printf(&quot;%d %d %d %d %d %d %d %d\n&quot;, a, b, c, d, e, f, g, h);
     /* printf(&quot;%d\n&quot;, frod); */
     frod = 12;
     printf(&quot;%d\n&quot;, frod);
     frod = e;
     printf(&quot;%d\n&quot;, frod);
  
     /* Following should compile without warning.  */
     printf (&quot;enum to int: %u\n&quot;, deref_uintptr(&amp;epos));
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00170.c
  error at ./tests/single-exec/00170.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00171.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
     int a;
     int *b;
     int *c;
  
     a = 42;
     b = &amp;a;
     c = NULL;
  
     printf(&quot;%d\n&quot;, *b);
  
     if (b == NULL)
        printf(&quot;b is NULL\n&quot;);
     else
        printf(&quot;b is not NULL\n&quot;);
  
     if (c == NULL)
        printf(&quot;c is NULL\n&quot;);
     else
        printf(&quot;c is not NULL\n&quot;);
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00171.c
  error at ./tests/single-exec/00171.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00172.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
     int a;
     int b;
     int *d;
     int *e;
     d = &amp;a;
     e = &amp;b;
     a = 12;
     b = 34;
     printf(&quot;%d\n&quot;, *d);
     printf(&quot;%d\n&quot;, *e);
     printf(&quot;%d\n&quot;, d == e);
     printf(&quot;%d\n&quot;, d != e);
     d = e;
     printf(&quot;%d\n&quot;, d == e);
     printf(&quot;%d\n&quot;, d != e);
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00172.c
  error at ./tests/single-exec/00172.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00173.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
     int x = &#x27;a&#x27;;
     char y = x;
  
     char *a = &quot;hello&quot;;
  
     printf(&quot;%s\n&quot;, a);
  
     int c;
     c = *a;
  
     char *b;
     for (b = a; *b != 0; b++)
        printf(&quot;%c: %d\n&quot;, *b, *b);
  
     char destarray[10];
     char *dest = &amp;destarray[0];
     char *src = a;
  
     while (*src != 0)
        *dest++ = *src++;
  
     *dest = 0;
  
     printf(&quot;copied string is %s\n&quot;, destarray);
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00173.c
  error at ./tests/single-exec/00173.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00174.c
  #include &lt;stdio.h&gt;
  #include &lt;math.h&gt;
  
  int main()
  {
     // variables
     float a = 12.34 + 56.78;
     printf(&quot;%f\n&quot;, a);
  
     // infix operators
     printf(&quot;%f\n&quot;, 12.34 + 56.78);
     printf(&quot;%f\n&quot;, 12.34 - 56.78);
     printf(&quot;%f\n&quot;, 12.34 * 56.78);
     printf(&quot;%f\n&quot;, 12.34 / 56.78);
  
     // comparison operators
     printf(&quot;%d %d %d %d %d %d\n&quot;, 12.34 &lt; 56.78, 12.34 &lt;= 56.78, 12.34 == 56.78, 12.34 &gt;= 56.78, 12.34 &gt; 56.78, 12.34 != 56.78);
     printf(&quot;%d %d %d %d %d %d\n&quot;, 12.34 &lt; 12.34, 12.34 &lt;= 12.34, 12.34 == 12.34, 12.34 &gt;= 12.34, 12.34 &gt; 12.34, 12.34 != 12.34);
     printf(&quot;%d %d %d %d %d %d\n&quot;, 56.78 &lt; 12.34, 56.78 &lt;= 12.34, 56.78 == 12.34, 56.78 &gt;= 12.34, 56.78 &gt; 12.34, 56.78 != 12.34);
  
     // assignment operators
     a = 12.34;
     a += 56.78;
     printf(&quot;%f\n&quot;, a);
  
     a = 12.34;
     a -= 56.78;
     printf(&quot;%f\n&quot;, a);
  
     a = 12.34;
     a *= 56.78;
     printf(&quot;%f\n&quot;, a);
  
     a = 12.34;
     a /= 56.78;
     printf(&quot;%f\n&quot;, a);
  
     // prefix operators
     printf(&quot;%f\n&quot;, +12.34);
     printf(&quot;%f\n&quot;, -12.34);
  
     // type coercion
     a = 2;
     printf(&quot;%f\n&quot;, a);
     printf(&quot;%f\n&quot;, sin(2));
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00174.c
  error at ./tests/single-exec/00174.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00175.c
  #include &lt;stdio.h&gt;
  
  void charfunc(char a)
  {
     printf(&quot;char: %c\n&quot;, a);
  }
  
  void intfunc(int a)
  {
     printf(&quot;int: %d\n&quot;, a);
  }
  
  void floatfunc(float a)
  {
     printf(&quot;float: %f\n&quot;, a);
  }
  
  int main()
  {
     charfunc(&#x27;a&#x27;);
     charfunc(98);
     charfunc(99.0);
  
     intfunc(&#x27;a&#x27;);
     intfunc(98);
     intfunc(99.0);
  
     floatfunc(&#x27;a&#x27;);
     floatfunc(98);
     floatfunc(99.0);
  
     /* printf(&quot;%c %d %f\n&quot;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;); */
     /* printf(&quot;%c %d %f\n&quot;, 97, 98, 99); */
     /* printf(&quot;%c %d %f\n&quot;, 97.0, 98.0, 99.0); */
  
     char b = 97;
     char c = 97.0;
  
     printf(&quot;%d %d\n&quot;, b, c);
  
     int d = &#x27;a&#x27;;
     int e = 97.0;
  
     printf(&quot;%d %d\n&quot;, d, e);
  
     float f = &#x27;a&#x27;;
     float g = 97;
  
     printf(&quot;%f %f\n&quot;, f, g);
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00175.c
  error at ./tests/single-exec/00175.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00176.c
  #include &lt;stdio.h&gt;
  
  int array[16];
  
  //Swap integer values by array indexes
  void swap(int a, int b)
  {
     int tmp  = array[a];
     array[a] = array[b];
     array[b] = tmp;
  }
  
  //Partition the array into two halves and return the
  //index about which the array is partitioned
  int partition(int left, int right)
  {
     int pivotIndex = left;
     int pivotValue = array[pivotIndex];
     int index = left;
     int i;
  
     swap(pivotIndex, right);
     for(i = left; i &lt; right; i++)
     {
        if(array[i] &lt; pivotValue)
        {
           swap(i, index);
           index += 1;
        }
     }
     swap(right, index);
  
     return index;
  }
  
  //Quicksort the array
  void quicksort(int left, int right)
  {
     if(left &gt;= right)
        return;
  
     int index = partition(left, right);
     quicksort(left, index - 1);
     quicksort(index + 1, right);
  }
  
  int main()
  {
     int i;
  
     array[0] = 62;
     array[1] = 83;
     array[2] = 4;
     array[3] = 89;
     array[4] = 36;
     array[5] = 21;
     array[6] = 74;
     array[7] = 37;
     array[8] = 65;
     array[9] = 33;
     array[10] = 96;
     array[11] = 38;
     array[12] = 53;
     array[13] = 16;
     array[14] = 74;
     array[15] = 55;
  
     for (i = 0; i &lt; 16; i++)
        printf(&quot;%d &quot;, array[i]);
  
     printf(&quot;\n&quot;);
  
     quicksort(0, 15);
  
     for (i = 0; i &lt; 16; i++)
        printf(&quot;%d &quot;, array[i]);
  
     printf(&quot;\n&quot;);
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00176.c
  error at ./tests/single-exec/00176.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00177.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
     printf(&quot;%d\n&quot;, &#x27;\1&#x27;);
     printf(&quot;%d\n&quot;, &#x27;\10&#x27;);
     printf(&quot;%d\n&quot;, &#x27;\100&#x27;);
     printf(&quot;%d\n&quot;, &#x27;\x01&#x27;);
     printf(&quot;%d\n&quot;, &#x27;\x0e&#x27;);
     printf(&quot;%d\n&quot;, &#x27;\x10&#x27;);
     printf(&quot;%d\n&quot;, &#x27;\x40&#x27;);
     printf(&quot;test \x40\n&quot;);
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00177.c
  error at ./tests/single-exec/00177.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00178.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
     char a;
     int b;
     double c;
  
     printf(&quot;%d\n&quot;, sizeof(a));
     printf(&quot;%d\n&quot;, sizeof(b));
     printf(&quot;%d\n&quot;, sizeof(c));
  
     printf(&quot;%d\n&quot;, sizeof(!a));
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00178.c
  error at ./tests/single-exec/00178.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00179.c
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;
  
  int main()
  {
     char a[10];
  
     strcpy(a, &quot;hello&quot;);
     printf(&quot;%s\n&quot;, a);
  
     strncpy(a, &quot;gosh&quot;, 2);
     printf(&quot;%s\n&quot;, a);
  
     printf(&quot;%d\n&quot;, strcmp(a, &quot;apple&quot;) &gt; 0);
     printf(&quot;%d\n&quot;, strcmp(a, &quot;goere&quot;) &gt; 0);
     printf(&quot;%d\n&quot;, strcmp(a, &quot;zebra&quot;) &lt; 0);
  
     printf(&quot;%d\n&quot;, strlen(a));
  
     strcat(a, &quot;!&quot;);
     printf(&quot;%s\n&quot;, a);
  
     printf(&quot;%d\n&quot;, strncmp(a, &quot;apple&quot;, 2) &gt; 0);
     printf(&quot;%d\n&quot;, strncmp(a, &quot;goere&quot;, 2) == 0);
     printf(&quot;%d\n&quot;, strncmp(a, &quot;goerg&quot;, 2) == 0);
     printf(&quot;%d\n&quot;, strncmp(a, &quot;zebra&quot;, 2) &lt; 0);
  
     printf(&quot;%s\n&quot;, strchr(a, &#x27;o&#x27;));
     printf(&quot;%s\n&quot;, strrchr(a, &#x27;l&#x27;));
     printf(&quot;%d\n&quot;, strrchr(a, &#x27;x&#x27;) == NULL);
  
     memset(&amp;a[1], &#x27;r&#x27;, 4);
     printf(&quot;%s\n&quot;, a);
  
     memcpy(&amp;a[2], a, 2);
     printf(&quot;%s\n&quot;, a);
  
     printf(&quot;%d\n&quot;, memcmp(a, &quot;apple&quot;, 4) &gt; 0);
     printf(&quot;%d\n&quot;, memcmp(a, &quot;grgr&quot;, 4) == 0);
     printf(&quot;%d\n&quot;, memcmp(a, &quot;zebra&quot;, 4) &lt; 0);
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00179.c
  error at ./tests/single-exec/00179.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00180.c
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;
  
  int main()
  {
     char a[10];
     strcpy(a, &quot;abcdef&quot;);
     printf(&quot;%s\n&quot;, &amp;a[1]);
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00180.c
  error at ./tests/single-exec/00180.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00181.c
  /* example from http://barnyard.syr.edu/quickies/hanoi.c */
  
  /* hanoi.c: solves the tower of hanoi problem. (Programming exercise.) */
  /* By Terry R. McConnell (12/2/97) */
  /* Compile: cc -o hanoi hanoi.c */
  
  /* This program does no error checking. But then, if it&#x27;s right, 
     it&#x27;s right ... right ? */
  
  
  /* The original towers of hanoi problem seems to have been originally posed
     by one M. Claus in 1883. There is a popular legend that goes along with
     it that has been often repeated and paraphrased. It goes something like this:
     In the great temple at Benares there are 3 golden spikes. On one of them,
     God placed 64 disks increasing in size from bottom to top, at the beginning
     of time. Since then, and to this day, the priest on duty constantly transfers
     disks, one at a time, in such a way that no larger disk is ever put on top
     of a smaller one. When the disks have been transferred entirely to another
     spike the Universe will come to an end in a large thunderclap.
  
     This paraphrases the original legend due to DeParville, La Nature, Paris 1884,
     Part I, 285-286. For this and further information see: Mathematical 
     Recreations &amp; Essays, W.W. Rouse Ball, MacMillan, NewYork, 11th Ed. 1967,
     303-305.
   *
   *
   */
  
  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;
  
  #define TRUE 1
  #define FALSE 0
  
  /* This is the number of &quot;disks&quot; on tower A initially. Taken to be 64 in the
   * legend. The number of moves required, in general, is 2^N - 1. For N = 64,
   * this is 18,446,744,073,709,551,615 */
  #define N 4
  
  /* These are the three towers. For example if the state of A is 0,1,3,4, that
   * means that there are three discs on A of sizes 1, 3, and 4. (Think of right
   * as being the &quot;down&quot; direction.) */
  int A[N], B[N], C[N]; 
  
  void Hanoi(int,int*,int*,int*);
  
  /* Print the current configuration of A, B, and C to the screen */
  void PrintAll()
  {
     int i;
  
     printf(&quot;A: &quot;);
     for(i=0;i&lt;N;i++)printf(&quot; %d &quot;,A[i]);
     printf(&quot;\n&quot;);
  
     printf(&quot;B: &quot;);
     for(i=0;i&lt;N;i++)printf(&quot; %d &quot;,B[i]);
     printf(&quot;\n&quot;);
  
     printf(&quot;C: &quot;);
     for(i=0;i&lt;N;i++)printf(&quot; %d &quot;,C[i]);
     printf(&quot;\n&quot;);
     printf(&quot;------------------------------------------\n&quot;);
     return;
  }
  
  /* Move the leftmost nonzero element of source to dest, leave behind 0. */
  /* Returns the value moved (not used.) */
  int Move(int *source, int *dest)
  {
     int i = 0, j = 0;
  
     while (i&lt;N &amp;&amp; (source[i])==0) i++;
     while (j&lt;N &amp;&amp; (dest[j])==0) j++;
  
     dest[j-1] = source[i];
     source[i] = 0;
     PrintAll();       /* Print configuration after each move. */
     return dest[j-1];
  }
  
  
  /* Moves first n nonzero numbers from source to dest using the rules of Hanoi.
     Calls itself recursively.
     */
  void Hanoi(int n,int *source, int *dest, int *spare)
  {
     int i;
     if(n==1){
        Move(source,dest);
        return;
     }
  
     Hanoi(n-1,source,spare,dest);
     Move(source,dest);
     Hanoi(n-1,spare,dest,source);	
     return;
  }
  
  int main()
  {
     int i;
  
     /* initialize the towers */
     for(i=0;i&lt;N;i++)A[i]=i+1;
     for(i=0;i&lt;N;i++)B[i]=0;
     for(i=0;i&lt;N;i++)C[i]=0;
  
     printf(&quot;Solution of Tower of Hanoi Problem with %d Disks\n\n&quot;,N);
  
     /* Print the starting state */
     printf(&quot;Starting state:\n&quot;);
     PrintAll();
     printf(&quot;\n\nSubsequent states:\n\n&quot;);
  
     /* Do it! Use A = Source, B = Destination, C = Spare */
     Hanoi(N,A,B,C);
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00181.c
  error at ./tests/single-exec/00181.c:29:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00182.c
  /* example from http://barnyard.syr.edu/quickies/led.c */
  
  /* led.c: print out number as if on 7 line led display. I.e., write integer
     given on command line like this:  
        _   _       _  
     |  _|  _| |_| |_  
     | |_   _|   |  _| etc.
  
     We assume the terminal behaves like a classical teletype. So the top
     lines of all digits have to be printed first, then the middle lines of
     all digits, etc.
  
     By Terry R. McConnell
  
  compile: cc -o led led.c
  
  If you just want to link in the subroutine print_led that does all the
  work, compile with -DNO_MAIN, and declare the following in any source file
  that uses the call:
  
  extern void print_led(unsigned long x, char *buf);
  
  Bug: you cannot call repeatedly to print more than one number to a line.
  That would require curses or some other terminal API that allows moving the
  cursor to a previous line.
  
  */
  
  
  
  #include &lt;stdlib.h&gt;
  #include &lt;stdio.h&gt;
  
  #define MAX_DIGITS 32
  #define NO_MAIN
  
  
  /* Print the top line of the digit d into buffer. 
     Does not null terminate buffer. */
  
  void topline(int d, char *p){
  
     *p++ = &#x27; &#x27;;
     switch(d){
  
        /* all these have _ on top line */
  
        case 0:
        case 2:
        case 3:
        case 5:
        case 7:
        case 8:
        case 9:
           *p++ = &#x27;_&#x27;;
           break;
        default:
           *p++=&#x27; &#x27;;
  
     }
     *p++=&#x27; &#x27;;
  }
  
  /* Print the middle line of the digit d into the buffer. 
     Does not null terminate. */
  
  void midline(int d, char *p){
  
     switch(d){
  
        /* those that have leading | on middle line */
  
        case 0:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
           *p++=&#x27;|&#x27;;
           break;
        default:
           *p++=&#x27; &#x27;;	
     }
     switch(d){
  
        /* those that have _ on middle line */
  
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
           *p++=&#x27;_&#x27;;
           break;
        default:
           *p++=&#x27; &#x27;;
  
     }
     switch(d){
  
        /* those that have closing | on middle line */
  
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 7:
        case 8:
        case 9:
           *p++=&#x27;|&#x27;;
           break;
        default:
           *p++=&#x27; &#x27;;
  
     }
  }
  
  /* Print the bottom line of the digit d. Does not null terminate. */
  
  void botline(int d, char *p){
  
  
     switch(d){
  
        /* those that have leading | on bottom line */
  
        case 0:
        case 2:
        case 6:
        case 8:
           *p++=&#x27;|&#x27;;
           break;
        default:
           *p++=&#x27; &#x27;;	
     }
     switch(d){
  
        /* those that have _ on bottom line */
  
        case 0:
        case 2:
        case 3:
        case 5:
        case 6:
        case 8:
           *p++=&#x27;_&#x27;;
           break;
        default:
           *p++=&#x27; &#x27;;
  
     }
     switch(d){
  
        /* those that have closing | on bottom line */
  
        case 0:
        case 1:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
           *p++=&#x27;|&#x27;;
           break;
        default:
           *p++=&#x27; &#x27;;
  
     }
  }
  
  /* Write the led representation of integer to string buffer. */
  
  void print_led(unsigned long x, char *buf)
  {
  
     int i=0,n;
     static int d[MAX_DIGITS];
  
  
     /* extract digits from x */
  
     n = ( x == 0L ? 1 : 0 );  /* 0 is a digit, hence a special case */
  
     while(x){
        d[n++] = (int)(x%10L);
        if(n &gt;= MAX_DIGITS)break;
        x = x/10L;
     }
  
     /* print top lines of all digits */
  
     for(i=n-1;i&gt;=0;i--){
        topline(d[i],buf);
        buf += 3;
        *buf++=&#x27; &#x27;;
     }
     *buf++=&#x27;\n&#x27;; /* move teletype to next line */
  
     /* print middle lines of all digits */
  
     for(i=n-1;i&gt;=0;i--){
        midline(d[i],buf);
        buf += 3;
        *buf++=&#x27; &#x27;;
     }
     *buf++=&#x27;\n&#x27;;
  
     /* print bottom lines of all digits */
  
     for(i=n-1;i&gt;=0;i--){
        botline(d[i],buf);
        buf += 3;
        *buf++=&#x27; &#x27;;
     }
     *buf++=&#x27;\n&#x27;;
     *buf=&#x27;\0&#x27;;
  }
  
  int main()
  {
     char buf[5*MAX_DIGITS];
     print_led(1234567, buf);
     printf(&quot;%s\n&quot;,buf);
  
     return 0;
  }
  
  #ifndef NO_MAIN
  int main(int argc, char **argv)
  {
  
     int i=0,n;
     long x;
     static int d[MAX_DIGITS];
     char buf[5*MAX_DIGITS];
  
     if(argc != 2){
        fprintf(stderr,&quot;led: usage: led integer\n&quot;);
        return 1;
     }
  
     /* fetch argument from command line */
  
     x = atol(argv[1]);
  
     /* sanity check */
  
     if(x&lt;0){
        fprintf(stderr,&quot;led: %d must be non-negative\n&quot;,x);
        return 1;
     }
  
     print_led(x,buf);
     printf(&quot;%s\n&quot;,buf);
  
     return 0;
  
  }
  #endif
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00182.c
  error at ./tests/single-exec/00182.c:31:10
  
  #include &lt;stdlib.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00183.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
     int Count;
  
     for (Count = 0; Count &lt; 10; Count++)
     {
        printf(&quot;%d\n&quot;, (Count &lt; 5) ? (Count*Count) : (Count * 3));
     }
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00183.c
  error at ./tests/single-exec/00183.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00184.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
     char a;
     short b;
  
     printf(&quot;%d %d\n&quot;, sizeof(char), sizeof(a));
     printf(&quot;%d %d\n&quot;, sizeof(short), sizeof(b));
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00184.c
  error at ./tests/single-exec/00184.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00185.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
     int Count;
  
     int Array[10] = { 12, 34, 56, 78, 90, 123, 456, 789, 8642, 9753 };
  
     for (Count = 0; Count &lt; 10; Count++)
        printf(&quot;%d: %d\n&quot;, Count, Array[Count]);
  
     int Array2[10] = { 12, 34, 56, 78, 90, 123, 456, 789, 8642, 9753, };
  
     for (Count = 0; Count &lt; 10; Count++)
        printf(&quot;%d: %d\n&quot;, Count, Array2[Count]);
  
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00185.c
  error at ./tests/single-exec/00185.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00186.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
     char Buf[100];
     int Count;
  
     for (Count = 1; Count &lt;= 20; Count++)
     {
        sprintf(Buf, &quot;-&gt;%02d&lt;-\n&quot;, Count);
        printf(&quot;%s&quot;, Buf);
     }
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00186.c
  error at ./tests/single-exec/00186.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00187.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
     FILE *f = fopen(&quot;fred.txt&quot;, &quot;w&quot;);
     fwrite(&quot;hello\nhello\n&quot;, 1, 12, f);
     fclose(f);
  
     char freddy[7];
     f = fopen(&quot;fred.txt&quot;, &quot;r&quot;);
     if (fread(freddy, 1, 6, f) != 6)
        printf(&quot;couldn&#x27;t read fred.txt\n&quot;);
  
     freddy[6] = &#x27;\0&#x27;;
     fclose(f);
  
     printf(&quot;%s&quot;, freddy);
  
     int InChar;
     char ShowChar;
     f = fopen(&quot;fred.txt&quot;, &quot;r&quot;);
     while ( (InChar = fgetc(f)) != EOF)
     {
        ShowChar = InChar;
        if (ShowChar &lt; &#x27; &#x27;)
           ShowChar = &#x27;.&#x27;;
  
        printf(&quot;ch: %d &#x27;%c&#x27;\n&quot;, InChar, ShowChar);
     }
     fclose(f);
  
     f = fopen(&quot;fred.txt&quot;, &quot;r&quot;);
     while ( (InChar = getc(f)) != EOF)
     {
        ShowChar = InChar;
        if (ShowChar &lt; &#x27; &#x27;)
           ShowChar = &#x27;.&#x27;;
  
        printf(&quot;ch: %d &#x27;%c&#x27;\n&quot;, InChar, ShowChar);
     }
     fclose(f);
  
     f = fopen(&quot;fred.txt&quot;, &quot;r&quot;);
     while (fgets(freddy, sizeof(freddy), f) != NULL)
        printf(&quot;x: %s&quot;, freddy);
  
     fclose(f);
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00187.c
  error at ./tests/single-exec/00187.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00188.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
     printf(&quot;#include test\n&quot;);
  
  #if 1
  #if 0
     printf(&quot;a\n&quot;);
  #else
     printf(&quot;b\n&quot;);
  #endif
  #else
  #if 0
     printf(&quot;c\n&quot;);
  #else
     printf(&quot;d\n&quot;);
  #endif
  #endif
  
  #if 0
  #if 1
     printf(&quot;e\n&quot;);
  #else
     printf(&quot;f\n&quot;);
  #endif
  #else
  #if 1
     printf(&quot;g\n&quot;);
  #else
     printf(&quot;h\n&quot;);
  #endif
  #endif
  
  #define DEF
  
  #ifdef DEF
  #ifdef DEF
     printf(&quot;i\n&quot;);
  #else
     printf(&quot;j\n&quot;);
  #endif
  #else
  #ifdef DEF
     printf(&quot;k\n&quot;);
  #else
     printf(&quot;l\n&quot;);
  #endif
  #endif
  
  #ifndef DEF
  #ifndef DEF
     printf(&quot;m\n&quot;);
  #else
     printf(&quot;n\n&quot;);
  #endif
  #else
  #ifndef DEF
     printf(&quot;o\n&quot;);
  #else
     printf(&quot;p\n&quot;);
  #endif
  #endif
  
  #define ONE 1
  #define ZERO 0
  
  #if ONE
  #if ZERO
     printf(&quot;q\n&quot;);
  #else
     printf(&quot;r\n&quot;);
  #endif
  #else
  #if ZERO
     printf(&quot;s\n&quot;);
  #else
     printf(&quot;t\n&quot;);
  #endif
  #endif
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00188.c
  error at ./tests/single-exec/00188.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00189.c
  #include &lt;stdio.h&gt;
  
  int fred(int p)
  {
     printf(&quot;yo %d\n&quot;, p);
     return 42;
  }
  
  int (*f)(int) = &amp;fred;
  
  /* To test what this is supposed to test the destination function
     (fprint here) must not be called directly anywhere in the test.  */
  int (*fprintfptr)(FILE *, const char *, ...) = &amp;fprintf;
  
  int main()
  {
     fprintfptr(stdout, &quot;%d\n&quot;, (*f)(24));
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00189.c
  error at ./tests/single-exec/00189.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00190.c
  #include &lt;stdio.h&gt;
  
  void fred(void)
  {
     printf(&quot;yo\n&quot;);
  }
  
  int main()
  {
     fred();
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00190.c
  error at ./tests/single-exec/00190.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00191.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
     int a;
  
     for (a = 0; a &lt; 2; a++)
     {
        int b = a;
     }
  
     printf(&quot;it&#x27;s all good\n&quot;);
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00191.c
  error at ./tests/single-exec/00191.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00192.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
     int Count = 0;
  
     for (;;)
     {
        Count++;
        printf(&quot;%d\n&quot;, Count);
        if (Count &gt;= 10)
           break;
     }
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00192.c
  error at ./tests/single-exec/00192.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00193.c
  #include &lt;stdio.h&gt;
  
  void fred(int x)
  {
     switch (x)
     {
        case 1: printf(&quot;1\n&quot;); return;
        case 2: printf(&quot;2\n&quot;); break;
        case 3: printf(&quot;3\n&quot;); return;
     }
  
     printf(&quot;out\n&quot;);
  }
  
  int main()
  {
     fred(1);
     fred(2);
     fred(3);
  
     return 0;
  }    
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00193.c
  error at ./tests/single-exec/00193.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00194.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
     int a;
     char b;
  
     a = 0;
     while (a &lt; 2)
     {
        printf(&quot;%d&quot;, a++);
        break;
  
        b = &#x27;A&#x27;;
        while (b &lt; &#x27;C&#x27;)
        {
           printf(&quot;%c&quot;, b++);
        }
        printf(&quot;e&quot;);
     }
     printf(&quot;\n&quot;);
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00194.c
  error at ./tests/single-exec/00194.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00195.c
  #include &lt;stdio.h&gt;
  
  struct point
  {
     double x;
     double y;
  };
  
  struct point point_array[100];
  
  int main()
  {
     int my_point = 10;
  
     point_array[my_point].x = 12.34;
     point_array[my_point].y = 56.78;
  
     printf(&quot;%f, %f\n&quot;, point_array[my_point].x, point_array[my_point].y);
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00195.c
  error at ./tests/single-exec/00195.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00196.c
  #include &lt;stdio.h&gt;
  
  int fred()
  {
     printf(&quot;fred\n&quot;);
     return 0;
  }
  
  int joe()
  {
     printf(&quot;joe\n&quot;);
     return 1;
  }
  
  int main()
  {
     printf(&quot;%d\n&quot;, fred() &amp;&amp; joe());
     printf(&quot;%d\n&quot;, fred() || joe());
     printf(&quot;%d\n&quot;, joe() &amp;&amp; fred());
     printf(&quot;%d\n&quot;, joe() || fred());
     printf(&quot;%d\n&quot;, fred() &amp;&amp; (1 + joe()));
     printf(&quot;%d\n&quot;, fred() || (0 + joe()));
     printf(&quot;%d\n&quot;, joe() &amp;&amp; (0 + fred()));
     printf(&quot;%d\n&quot;, joe() || (1 + fred()));
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00196.c
  error at ./tests/single-exec/00196.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00197.c
  #include &lt;stdio.h&gt;
  
  static int fred = 1234;
  static int joe;
  
  void henry()
  {
     static int fred = 4567;
  
     printf(&quot;%d\n&quot;, fred);
     fred++;
  }
  
  int main()
  {
     printf(&quot;%d\n&quot;, fred);
     henry();
     henry();
     henry();
     henry();
     printf(&quot;%d\n&quot;, fred);
     fred = 8901;
     joe = 2345;
     printf(&quot;%d\n&quot;, fred);
     printf(&quot;%d\n&quot;, joe);
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00197.c
  error at ./tests/single-exec/00197.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00198.c
  #include &lt;stdio.h&gt;
  
  enum fred { a, b, c };
  
  int main()
  {
     printf(&quot;a=%d\n&quot;, a);
     printf(&quot;b=%d\n&quot;, b);
     printf(&quot;c=%d\n&quot;, c);
  
     enum fred d;
  
     typedef enum { e, f, g } h;
     typedef enum { i, j, k } m;
  
     printf(&quot;e=%d\n&quot;, e);
     printf(&quot;f=%d\n&quot;, f);
     printf(&quot;g=%d\n&quot;, g);
  
     printf(&quot;i=%d\n&quot;, i);
     printf(&quot;j=%d\n&quot;, j);
     printf(&quot;k=%d\n&quot;, k);
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00198.c
  error at ./tests/single-exec/00198.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00199.c
  #include &lt;stdio.h&gt;
  
  void fred()
  {
     printf(&quot;In fred()\n&quot;);
     goto done;
     printf(&quot;In middle\n&quot;);
  done:
     printf(&quot;At end\n&quot;);
  }
  
  void joe()
  {
     int b = 5678;
  
     printf(&quot;In joe()\n&quot;);
  
     {
        int c = 1234;
        printf(&quot;c = %d\n&quot;, c);
        goto outer;
        printf(&quot;uh-oh\n&quot;);
     }
  
  outer:    
  
     printf(&quot;done\n&quot;);
  }
  
  void henry()
  {
     int a;
  
     printf(&quot;In henry()\n&quot;);
     goto inner;
  
     {
        int b;
  inner:    
        b = 1234;
        printf(&quot;b = %d\n&quot;, b);
     }
  
     printf(&quot;done\n&quot;);
  }
  
  int main()
  {
     fred();
     joe();
     henry();
  
     return 0;
  }
  
  /* vim: set expandtab ts=4 sw=3 sts=3 tw=80 :*/
  +9cc ./tests/single-exec/00199.c
  error at ./tests/single-exec/00199.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00200.c
  /* $Id: lshift-type.c 53089 2012-07-06 11:18:26Z vinc17/ypig $
  
  Tests on left-shift type, written by Vincent Lefevre &lt;vincent@vinc17.net&gt;.
  
  ISO C99 TC3 says: [6.5.7#3] &quot;The integer promotions are performed on
  each of the operands. The type of the result is that of the promoted
  left operand.&quot;
  */
  
  #include &lt;stdio.h&gt;
  
  #define PTYPE(M) ((M) &lt; 0 || -(M) &lt; 0 ? -1 : 1) * (int) sizeof((M)+0)
  #define CHECK(X,T) check(#X, PTYPE(X), PTYPE((X) &lt;&lt; (T) 1))
  #define TEST1(X,T) do { CHECK(X,T); CHECK(X,unsigned T); } while (0)
  #define TEST2(X)                 \
    do                             \
      {                            \
        TEST1((X),short);          \
        TEST1((X),int);            \
        TEST1((X),long);           \
        TEST1((X),long long);      \
      }                            \
    while (0)
  #define TEST3(X,T) do { TEST2((T)(X)); TEST2((unsigned T)(X)); } while (0)
  #define TEST4(X)                 \
    do                             \
      {                            \
        TEST3((X),short);          \
        TEST3((X),int);            \
        TEST3((X),long);           \
        TEST3((X),long long);      \
      }                            \
   while (0)
  
  static int debug, nfailed = 0;
  
  static void check (const char *s, int arg1, int shift)
  {
    int failed = arg1 != shift;
    if (debug || failed)
      printf (&quot;%s %d %d\n&quot;, s, arg1, shift);
    nfailed += failed;
  }
  
  int main (int argc, char **argv)
  {
    debug = argc &gt; 1;
    TEST4(1);
    TEST4(-1);
    printf (&quot;%d test(s) failed\n&quot;, nfailed);
    return nfailed != 0;
  }
  +9cc ./tests/single-exec/00200.c
  error at ./tests/single-exec/00200.c:10:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00201.c
  #include &lt;stdio.h&gt;	// printf()
  
  #define CAT2(a,b) a##b
  #define CAT(a,b) CAT2(a,b)
  #define AB(x) CAT(x,y)
  
  int main(void)
  {
    int xy = 42;
    printf(&quot;%d\n&quot;, CAT(A,B)(x));
    return 0;
  }
  +9cc ./tests/single-exec/00201.c
  error at ./tests/single-exec/00201.c:1:10
  
  #include &lt;stdio.h&gt;	// printf()
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00202.c
  #include &lt;stdio.h&gt;
  
  #define P(A,B) A ## B ; bob
  #define Q(A,B) A ## B+
  
  int main(void)
  {
      int bob, jim = 21;
      bob = P(jim,) *= 2;
      printf(&quot;jim: %d, bob: %d\n&quot;, jim, bob);
      jim = 60 Q(+,)3;
      printf(&quot;jim: %d\n&quot;, jim);
      return 0;
  }
  +9cc ./tests/single-exec/00202.c
  error at ./tests/single-exec/00202.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00203.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
      long long int res = 0;
  
      if (res &lt; -2147483648LL) {
          printf(&quot;Error: 0 &lt; -2147483648\n&quot;);
          return 1;
      }
      else
      if (2147483647LL &lt; res) {
          printf(&quot;Error: 2147483647 &lt; 0\n&quot;);
          return 2;
      }
      else
          printf(&quot;long long constant test ok.\n&quot;);
      return 0;
  }
  +9cc ./tests/single-exec/00203.c
  error at ./tests/single-exec/00203.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00204.c
  // This program is designed to test some arm64-specific things, such as the
  // calling convention, but should give the same results on any architecture.
  
  #include &lt;stdarg.h&gt;
  #include &lt;stdint.h&gt;
  #include &lt;stdio.h&gt;
  
  struct s1 { char x[1]; } s1 = { &quot;0&quot; };
  struct s2 { char x[2]; } s2 = { &quot;12&quot; };
  struct s3 { char x[3]; } s3 = { &quot;345&quot; };
  struct s4 { char x[4]; } s4 = { &quot;6789&quot; };
  struct s5 { char x[5]; } s5 = { &quot;abcde&quot; };
  struct s6 { char x[6]; } s6 = { &quot;fghijk&quot; };
  struct s7 { char x[7]; } s7 = { &quot;lmnopqr&quot; };
  struct s8 { char x[8]; } s8 = { &quot;stuvwxyz&quot; };
  struct s9 { char x[9]; } s9 = { &quot;ABCDEFGHI&quot; };
  struct s10 { char x[10]; } s10 = { &quot;JKLMNOPQRS&quot; };
  struct s11 { char x[11]; } s11 = { &quot;TUVWXYZ0123&quot; };
  struct s12 { char x[12]; } s12 = { &quot;456789abcdef&quot; };
  struct s13 { char x[13]; } s13 = { &quot;ghijklmnopqrs&quot; };
  struct s14 { char x[14]; } s14 = { &quot;tuvwxyzABCDEFG&quot; };
  struct s15 { char x[15]; } s15 = { &quot;HIJKLMNOPQRSTUV&quot; };
  struct s16 { char x[16]; } s16 = { &quot;WXYZ0123456789ab&quot; };
  struct s17 { char x[17]; } s17 = { &quot;cdefghijklmnopqrs&quot; };
  
  struct hfa11 { float a; } hfa11 = { 11.1 };
  struct hfa12 { float a, b; } hfa12 = { 12.1, 12.2 };
  struct hfa13 { float a, b, c; } hfa13 = { 13.1, 13.2, 13.3 };
  struct hfa14 { float a, b, c, d; } hfa14 = { 14.1, 14.2, 14.3, 14.4 };
  
  struct hfa21 { double a; } hfa21 = { 21.1 };
  struct hfa22 { double a, b; } hfa22 = { 22.1, 22.2 };
  struct hfa23 { double a, b, c; } hfa23 = { 23.1, 23.2, 23.3 };
  struct hfa24 { double a, b, c, d; } hfa24 = { 24.1, 24.2, 24.3, 24.4 };
  
  struct hfa31 { long double a; } hfa31 = { 31.1 };
  struct hfa32 { long double a, b; } hfa32 = { 32.1, 32.2 };
  struct hfa33 { long double a, b, c; } hfa33 = { 33.1, 33.2, 33.3 };
  struct hfa34 { long double a, b, c, d; } hfa34 = { 34.1, 34.2, 34.3, 34.4 };
  
  void fa_s1(struct s1 a) { printf(&quot;%.1s\n&quot;, a.x); }
  void fa_s2(struct s2 a) { printf(&quot;%.2s\n&quot;, a.x); }
  void fa_s3(struct s3 a) { printf(&quot;%.3s\n&quot;, a.x); }
  void fa_s4(struct s4 a) { printf(&quot;%.4s\n&quot;, a.x); }
  void fa_s5(struct s5 a) { printf(&quot;%.5s\n&quot;, a.x); }
  void fa_s6(struct s6 a) { printf(&quot;%.6s\n&quot;, a.x); }
  void fa_s7(struct s7 a) { printf(&quot;%.7s\n&quot;, a.x); }
  void fa_s8(struct s8 a) { printf(&quot;%.8s\n&quot;, a.x); }
  void fa_s9(struct s9 a) { printf(&quot;%.9s\n&quot;, a.x); }
  void fa_s10(struct s10 a) { printf(&quot;%.10s\n&quot;, a.x); }
  void fa_s11(struct s11 a) { printf(&quot;%.11s\n&quot;, a.x); }
  void fa_s12(struct s12 a) { printf(&quot;%.12s\n&quot;, a.x); }
  void fa_s13(struct s13 a) { printf(&quot;%.13s\n&quot;, a.x); }
  void fa_s14(struct s14 a) { printf(&quot;%.14s\n&quot;, a.x); }
  void fa_s15(struct s15 a) { printf(&quot;%.15s\n&quot;, a.x); }
  void fa_s16(struct s16 a) { printf(&quot;%.16s\n&quot;, a.x); }
  void fa_s17(struct s17 a) { printf(&quot;%.17s\n&quot;, a.x); }
  
  void fa_hfa11(struct hfa11 a)
  { printf(&quot;%.1f\n&quot;, a.a); }
  void fa_hfa12(struct hfa12 a)
  { printf(&quot;%.1f %.1f\n&quot;, a.a, a.a); }
  void fa_hfa13(struct hfa13 a)
  { printf(&quot;%.1f %.1f %.1f\n&quot;, a.a, a.b, a.c); }
  void fa_hfa14(struct hfa14 a)
  { printf(&quot;%.1f %.1f %.1f %.1f\n&quot;, a.a, a.b, a.c, a.d); }
  
  void fa_hfa21(struct hfa21 a)
  { printf(&quot;%.1f\n&quot;, a.a); }
  void fa_hfa22(struct hfa22 a)
  { printf(&quot;%.1f %.1f\n&quot;, a.a, a.a); }
  void fa_hfa23(struct hfa23 a)
  { printf(&quot;%.1f %.1f %.1f\n&quot;, a.a, a.b, a.c); }
  void fa_hfa24(struct hfa24 a)
  { printf(&quot;%.1f %.1f %.1f %.1f\n&quot;, a.a, a.b, a.c, a.d); }
  
  void fa_hfa31(struct hfa31 a)
  { printf(&quot;%.1Lf\n&quot;, a.a); }
  void fa_hfa32(struct hfa32 a)
  { printf(&quot;%.1Lf %.1Lf\n&quot;, a.a, a.a); }
  void fa_hfa33(struct hfa33 a)
  { printf(&quot;%.1Lf %.1Lf %.1Lf\n&quot;, a.a, a.b, a.c); }
  void fa_hfa34(struct hfa34 a)
  { printf(&quot;%.1Lf %.1Lf %.1Lf %.1Lf\n&quot;, a.a, a.b, a.c, a.d); }
  
  void fa1(struct s8 a, struct s9 b, struct s10 c, struct s11 d,
           struct s12 e, struct s13 f)
  {
      printf(&quot;%.3s %.3s %.3s %.3s %.3s %.3s\n&quot;, a.x, b.x, c.x, d.x, e.x, f.x);
  }
  
  void fa2(struct s9 a, struct s10 b, struct s11 c, struct s12 d,
           struct s13 e, struct s14 f)
  {
      printf(&quot;%.3s %.3s %.3s %.3s %.3s %.3s\n&quot;, a.x, b.x, c.x, d.x, e.x, f.x);
  }
  
  void fa3(struct hfa14 a, struct hfa23 b, struct hfa32 c)
  {
      printf(&quot;%.1f %.1f %.1f %.1f %.1Lf %.1Lf\n&quot;,
             a.a, a.d, b.a, b.c, c.a, c.b);
  }
  
  void fa4(struct s1 a, struct hfa14 b, struct s2 c, struct hfa24 d,
           struct s3 e, struct hfa34 f)
  {
      printf(&quot;%.1s %.1f %.1f %.2s %.1f %.1f %.3s %.1Lf %.1Lf\n&quot;,
             a.x, b.a, b.d, c.x, d.a, d.d, e.x, f.a, f.d);
  }
  
  void arg(void)
  {
      printf(&quot;Arguments:\n&quot;);
      fa_s1(s1);
      fa_s2(s2);
      fa_s3(s3);
      fa_s4(s4);
      fa_s5(s5);
      fa_s6(s6);
      fa_s7(s7);
      fa_s8(s8);
      fa_s9(s9);
      fa_s10(s10);
      fa_s11(s11);
      fa_s12(s12);
      fa_s13(s13);
      fa_s14(s14);
      fa_s15(s15);
      fa_s16(s16);
      fa_s17(s17);
      fa_hfa11(hfa11);
      fa_hfa12(hfa12);
      fa_hfa13(hfa13);
      fa_hfa14(hfa14);
      fa_hfa21(hfa21);
      fa_hfa22(hfa22);
      fa_hfa23(hfa23);
      fa_hfa24(hfa24);
      fa_hfa31(hfa31);
      fa_hfa32(hfa32);
      fa_hfa33(hfa33);
      fa_hfa34(hfa34);
      fa1(s8, s9, s10, s11, s12, s13);
      fa2(s9, s10, s11, s12, s13, s14);
      fa3(hfa14, hfa23, hfa32);
      fa4(s1, hfa14, s2, hfa24, s3, hfa34);
  }
  
  struct s1 fr_s1(void) { return s1; }
  struct s2 fr_s2(void) { return s2; }
  struct s3 fr_s3(void) { return s3; }
  struct s4 fr_s4(void) { return s4; }
  struct s5 fr_s5(void) { return s5; }
  struct s6 fr_s6(void) { return s6; }
  struct s7 fr_s7(void) { return s7; }
  struct s8 fr_s8(void) { return s8; }
  struct s9 fr_s9(void) { return s9; }
  struct s10 fr_s10(void) { return s10; }
  struct s11 fr_s11(void) { return s11; }
  struct s12 fr_s12(void) { return s12; }
  struct s13 fr_s13(void) { return s13; }
  struct s14 fr_s14(void) { return s14; }
  struct s15 fr_s15(void) { return s15; }
  struct s16 fr_s16(void) { return s16; }
  struct s17 fr_s17(void) { return s17; }
  
  struct hfa11 fr_hfa11(void) { return hfa11; }
  struct hfa12 fr_hfa12(void) { return hfa12; }
  struct hfa13 fr_hfa13(void) { return hfa13; }
  struct hfa14 fr_hfa14(void) { return hfa14; }
  
  struct hfa21 fr_hfa21(void) { return hfa21; }
  struct hfa22 fr_hfa22(void) { return hfa22; }
  struct hfa23 fr_hfa23(void) { return hfa23; }
  struct hfa24 fr_hfa24(void) { return hfa24; }
  
  struct hfa31 fr_hfa31(void) { return hfa31; }
  struct hfa32 fr_hfa32(void) { return hfa32; }
  struct hfa33 fr_hfa33(void) { return hfa33; }
  struct hfa34 fr_hfa34(void) { return hfa34; }
  
  void ret(void)
  {
      struct s1 t1 = fr_s1();
      struct s2 t2 = fr_s2();
      struct s3 t3 = fr_s3();
      struct s4 t4 = fr_s4();
      struct s5 t5 = fr_s5();
      struct s6 t6 = fr_s6();
      struct s7 t7 = fr_s7();
      struct s8 t8 = fr_s8();
      struct s9 t9 = fr_s9();
      struct s10 t10 = fr_s10();
      struct s11 t11 = fr_s11();
      struct s12 t12 = fr_s12();
      struct s13 t13 = fr_s13();
      struct s14 t14 = fr_s14();
      struct s15 t15 = fr_s15();
      struct s16 t16 = fr_s16();
      struct s17 t17 = fr_s17();
      printf(&quot;Return values:\n&quot;);
      printf(&quot;%.1s\n&quot;, t1.x);
      printf(&quot;%.2s\n&quot;, t2.x);
      printf(&quot;%.3s\n&quot;, t3.x);
      printf(&quot;%.4s\n&quot;, t4.x);
      printf(&quot;%.5s\n&quot;, t5.x);
      printf(&quot;%.6s\n&quot;, t6.x);
      printf(&quot;%.7s\n&quot;, t7.x);
      printf(&quot;%.8s\n&quot;, t8.x);
      printf(&quot;%.9s\n&quot;, t9.x);
      printf(&quot;%.10s\n&quot;, t10.x);
      printf(&quot;%.11s\n&quot;, t11.x);
      printf(&quot;%.12s\n&quot;, t12.x);
      printf(&quot;%.13s\n&quot;, t13.x);
      printf(&quot;%.14s\n&quot;, t14.x);
      printf(&quot;%.15s\n&quot;, t15.x);
      printf(&quot;%.16s\n&quot;, t16.x);
      printf(&quot;%.17s\n&quot;, t17.x);
      printf(&quot;%.1f\n&quot;, fr_hfa11().a);
      printf(&quot;%.1f %.1f\n&quot;, fr_hfa12().a, fr_hfa12().b);
      printf(&quot;%.1f %.1f\n&quot;, fr_hfa13().a, fr_hfa13().c);
      printf(&quot;%.1f %.1f\n&quot;, fr_hfa14().a, fr_hfa14().d);
      printf(&quot;%.1f\n&quot;, fr_hfa21().a);
      printf(&quot;%.1f %.1f\n&quot;, fr_hfa22().a, fr_hfa22().b);
      printf(&quot;%.1f %.1f\n&quot;, fr_hfa23().a, fr_hfa23().c);
      printf(&quot;%.1f %.1f\n&quot;, fr_hfa24().a, fr_hfa24().d);
      printf(&quot;%.1Lf\n&quot;, fr_hfa31().a);
      printf(&quot;%.1Lf %.1Lf\n&quot;, fr_hfa32().a, fr_hfa32().b);
      printf(&quot;%.1Lf %.1Lf\n&quot;, fr_hfa33().a, fr_hfa33().c);
      printf(&quot;%.1Lf %.1Lf\n&quot;, fr_hfa34().a, fr_hfa34().d);
  }
  
  int match(const char **s, const char *f)
  {
      const char *p = *s;
      for (p = *s; *f &amp;&amp; *f == *p; f++, p++)
          ;
      if (!*f) {
          *s = p - 1;
          return 1;
      }
      return 0;
  }
  
  void myprintf(const char *format, ...)
  {
      const char *s;
      va_list ap;
      va_start(ap, format);
      for (s = format; *s; s++) {
          if (match(&amp;s, &quot;%7s&quot;)) {
              struct s7 t7 = va_arg(ap, struct s7);
              printf(&quot;%.7s&quot;, t7.x);
          }
          else if (match(&amp;s, &quot;%9s&quot;)) {
              struct s9 t9 = va_arg(ap, struct s9);
              printf(&quot;%.9s&quot;, t9.x);
          }
          else if (match(&amp;s, &quot;%hfa11&quot;)) {
              struct hfa11 x = va_arg(ap, struct hfa11);
              printf(&quot;%.1f,%.1f&quot;, x.a, x.a);
          }
          else if (match(&amp;s, &quot;%hfa12&quot;)) {
              struct hfa12 x = va_arg(ap, struct hfa12);
              printf(&quot;%.1f,%.1f&quot;, x.a, x.b);
          }
          else if (match(&amp;s, &quot;%hfa13&quot;)) {
              struct hfa13 x = va_arg(ap, struct hfa13);
              printf(&quot;%.1f,%.1f&quot;, x.a, x.c);
          }
          else if (match(&amp;s, &quot;%hfa14&quot;)) {
              struct hfa14 x = va_arg(ap, struct hfa14);
              printf(&quot;%.1f,%.1f&quot;, x.a, x.d);
          }
          else if (match(&amp;s, &quot;%hfa21&quot;)) {
              struct hfa21 x = va_arg(ap, struct hfa21);
              printf(&quot;%.1f,%.1f&quot;, x.a, x.a);
          }
          else if (match(&amp;s, &quot;%hfa22&quot;)) {
              struct hfa22 x = va_arg(ap, struct hfa22);
              printf(&quot;%.1f,%.1f&quot;, x.a, x.b);
          }
          else if (match(&amp;s, &quot;%hfa23&quot;)) {
              struct hfa23 x = va_arg(ap, struct hfa23);
              printf(&quot;%.1f,%.1f&quot;, x.a, x.c);
          }
          else if (match(&amp;s, &quot;%hfa24&quot;)) {
              struct hfa24 x = va_arg(ap, struct hfa24);
              printf(&quot;%.1f,%.1f&quot;, x.a, x.d);
          }
          else if (match(&amp;s, &quot;%hfa31&quot;)) {
              struct hfa31 x = va_arg(ap, struct hfa31);
              printf(&quot;%.1Lf,%.1Lf&quot;, x.a, x.a);
          }
          else if (match(&amp;s, &quot;%hfa32&quot;)) {
              struct hfa32 x = va_arg(ap, struct hfa32);
              printf(&quot;%.1Lf,%.1Lf&quot;, x.a, x.b);
          }
          else if (match(&amp;s, &quot;%hfa33&quot;)) {
              struct hfa33 x = va_arg(ap, struct hfa33);
              printf(&quot;%.1Lf,%.1Lf&quot;, x.a, x.c);
          }
          else if (match(&amp;s, &quot;%hfa34&quot;)) {
              struct hfa34 x = va_arg(ap, struct hfa34);
              printf(&quot;%.1Lf,%.1Lf&quot;, x.a, x.d);
          }
          else
              putchar(*s);
      }
      putchar(&#x27;\n&#x27;);
  }
  
  void stdarg(void)
  {
      printf(&quot;stdarg:\n&quot;);
      myprintf(&quot;%9s %9s %9s %9s %9s %9s&quot;, s9, s9, s9, s9, s9, s9);
      myprintf(&quot;%7s %9s %9s %9s %9s %9s&quot;, s7, s9, s9, s9, s9, s9);
  
      myprintf(&quot;HFA long double:&quot;);
      myprintf(&quot;%hfa34 %hfa34 %hfa34 %hfa34&quot;, hfa34, hfa34, hfa34, hfa34);
      myprintf(&quot;%hfa33 %hfa34 %hfa34 %hfa34&quot;, hfa33, hfa34, hfa34, hfa34);
      myprintf(&quot;%hfa32 %hfa34 %hfa34 %hfa34&quot;, hfa32, hfa34, hfa34, hfa34);
      myprintf(&quot;%hfa31 %hfa34 %hfa34 %hfa34&quot;, hfa31, hfa34, hfa34, hfa34);
  
      myprintf(&quot;%hfa32 %hfa33 %hfa33 %hfa33 %hfa33&quot;,
               hfa32, hfa33, hfa33, hfa33, hfa33);
      myprintf(&quot;%hfa31 %hfa33 %hfa33 %hfa33 %hfa33&quot;,
               hfa31, hfa33, hfa33, hfa33, hfa33);
      myprintf(&quot;%hfa33 %hfa33 %hfa33 %hfa33&quot;,
               hfa33, hfa33, hfa33, hfa33);
  
      myprintf(&quot;%hfa34 %hfa32 %hfa32 %hfa32 %hfa32&quot;,
               hfa34, hfa32, hfa32, hfa32, hfa32);
      myprintf(&quot;%hfa33 %hfa32 %hfa32 %hfa32 %hfa32&quot;,
               hfa33, hfa32, hfa32, hfa32, hfa32);
  
      myprintf(&quot;%hfa34 %hfa32 %hfa31 %hfa31 %hfa31 %hfa31&quot;,
               hfa34, hfa32, hfa31, hfa31, hfa31, hfa31);
  
      myprintf(&quot;HFA double:&quot;);
      myprintf(&quot;%hfa24 %hfa24 %hfa24 %hfa24&quot;, hfa24, hfa24, hfa24, hfa24);
      myprintf(&quot;%hfa23 %hfa24 %hfa24 %hfa24&quot;, hfa23, hfa24, hfa24, hfa24);
      myprintf(&quot;%hfa22 %hfa24 %hfa24 %hfa24&quot;, hfa22, hfa24, hfa24, hfa24);
      myprintf(&quot;%hfa21 %hfa24 %hfa24 %hfa24&quot;, hfa21, hfa24, hfa24, hfa24);
  
      myprintf(&quot;%hfa22 %hfa23 %hfa23 %hfa23 %hfa23&quot;,
               hfa22, hfa23, hfa23, hfa23, hfa23);
      myprintf(&quot;%hfa21 %hfa23 %hfa23 %hfa23 %hfa23&quot;,
               hfa21, hfa23, hfa23, hfa23, hfa23);
      myprintf(&quot;%hfa23 %hfa23 %hfa23 %hfa23&quot;,
               hfa23, hfa23, hfa23, hfa23);
  
      myprintf(&quot;%hfa24 %hfa22 %hfa22 %hfa22 %hfa22&quot;,
               hfa24, hfa22, hfa22, hfa22, hfa22);
      myprintf(&quot;%hfa23 %hfa22 %hfa22 %hfa22 %hfa22&quot;,
               hfa23, hfa22, hfa22, hfa22, hfa22);
  
      myprintf(&quot;%hfa24 %hfa22 %hfa21 %hfa21 %hfa21 %hfa21&quot;,
               hfa24, hfa22, hfa21, hfa21, hfa21, hfa21);
  
      myprintf(&quot;HFA float:&quot;);
      myprintf(&quot;%hfa14 %hfa14 %hfa14 %hfa14&quot;, hfa14, hfa14, hfa14, hfa14);
      myprintf(&quot;%hfa13 %hfa14 %hfa14 %hfa14&quot;, hfa13, hfa14, hfa14, hfa14);
      myprintf(&quot;%hfa12 %hfa14 %hfa14 %hfa14&quot;, hfa12, hfa14, hfa14, hfa14);
      myprintf(&quot;%hfa11 %hfa14 %hfa14 %hfa14&quot;, hfa11, hfa14, hfa14, hfa14);
  
      myprintf(&quot;%hfa12 %hfa13 %hfa13 %hfa13 %hfa13&quot;,
               hfa12, hfa13, hfa13, hfa13, hfa13);
      myprintf(&quot;%hfa11 %hfa13 %hfa13 %hfa13 %hfa13&quot;,
               hfa11, hfa13, hfa13, hfa13, hfa13);
      myprintf(&quot;%hfa13 %hfa13 %hfa13 %hfa13&quot;,
               hfa13, hfa13, hfa13, hfa13);
  
      myprintf(&quot;%hfa14 %hfa12 %hfa12 %hfa12 %hfa12&quot;,
               hfa14, hfa12, hfa12, hfa12, hfa12);
      myprintf(&quot;%hfa13 %hfa12 %hfa12 %hfa12 %hfa12&quot;,
               hfa13, hfa12, hfa12, hfa12, hfa12);
  
      myprintf(&quot;%hfa14 %hfa12 %hfa11 %hfa11 %hfa11 %hfa11&quot;,
               hfa14, hfa12, hfa11, hfa11, hfa11, hfa11);
  }
  
  void pll(unsigned long long x)
  {
      printf(&quot;%llx\n&quot;, x);
  }
  
  void movi(void)
  {
      printf(&quot;MOVI:\n&quot;);
      pll(0);
      pll(0xabcd);
      pll(0xabcd0000);
      pll(0xabcd00000000);
      pll(0xabcd000000000000);
      pll(0xffffabcd);
      pll(0xabcdffff);
      pll(0xffffffffffffabcd);
      pll(0xffffffffabcdffff);
      pll(0xffffabcdffffffff);
      pll(0xabcdffffffffffff);
      pll(0xaaaaaaaa);
      pll(0x5555555555555555);
      pll(0x77777777);
      pll(0x3333333333333333);
      pll(0xf8f8f8f8);
      pll(0x1e1e1e1e1e1e1e1e);
      pll(0x3f803f80);
      pll(0x01ff01ff01ff01ff);
      pll(0x007fffc0);
      pll(0x03fff80003fff800);
      pll(0x0007fffffffffe00);
  
      pll(0xabcd1234);
      pll(0xabcd00001234);
      pll(0xabcd000000001234);
      pll(0xabcd12340000);
      pll(0xabcd000012340000);
      pll(0xabcd123400000000);
      pll(0xffffffffabcd1234);
      pll(0xffffabcdffff1234);
      pll(0xabcdffffffff1234);
      pll(0xffffabcd1234ffff);
      pll(0xabcdffff1234ffff);
      pll(0xabcd1234ffffffff);
  
      pll(0xffffef0123456789);
      pll(0xabcdef012345ffff);
  
      pll(0xabcdef0123456789);
  }
  
  static uint32_t addip0(uint32_t x) { return x + 0; }
  static uint64_t sublp0(uint64_t x) { return x - 0; }
  static uint32_t addip123(uint32_t x) { return x + 123; }
  static uint64_t addlm123(uint64_t x) { return x + -123; }
  static uint64_t sublp4095(uint64_t x) { return x - 4095; }
  static uint32_t subim503808(uint32_t x) { return x - -503808; }
  static uint64_t addp12345(uint64_t x) { return x + 12345; }
  static uint32_t subp12345(uint32_t x) { return x - 12345; }
  
  static uint32_t mvni(uint32_t x) { return 0xffffffff - x; }
  static uint64_t negl(uint64_t x) { return 0 - x; }
  static uint32_t rsbi123(uint32_t x) { return 123 - x; }
  static uint64_t rsbl123(uint64_t x) { return 123 - x; }
  
  static uint32_t andi0(uint32_t x) { return x &amp; 0; }
  static uint64_t andlm1(uint64_t x) { return x &amp; -1; }
  static uint64_t orrl0(uint64_t x) { return x | 0; }
  static uint32_t orrim1(uint32_t x) { return x | -1; }
  static uint32_t eori0(uint32_t x) { return x ^ 0; }
  static uint64_t eorlm1(uint64_t x) { return x ^ -1; }
  static uint32_t and0xf0(uint32_t x) { return x &amp; 0xf0; }
  static uint64_t orr0xf0(uint64_t x) { return x | 0xf0; }
  static uint64_t eor0xf0(uint64_t x) { return x ^ 0xf0; }
  
  static uint32_t lsli0(uint32_t x) { return x &lt;&lt; 0; }
  static uint32_t lsri0(uint32_t x) { return x &gt;&gt; 0; }
  static int64_t asrl0(int64_t x) { return x &gt;&gt; 0; }
  static uint32_t lsli1(uint32_t x) { return x &lt;&lt; 1; }
  static uint32_t lsli31(uint32_t x) { return x &lt;&lt; 31; }
  static uint64_t lsll1(uint64_t x) { return x &lt;&lt; 1; }
  static uint64_t lsll63(uint64_t x) { return x &lt;&lt; 63; }
  static uint32_t lsri1(uint32_t x) { return x &gt;&gt; 1; }
  static uint32_t lsri31(uint32_t x) { return x &gt;&gt; 31; }
  static uint64_t lsrl1(uint64_t x) { return x &gt;&gt; 1; }
  static uint64_t lsrl63(uint64_t x) { return x &gt;&gt; 63; }
  static int32_t asri1(int32_t x) { return x &gt;&gt; 1; }
  static int32_t asri31(int32_t x) { return x &gt;&gt; 31; }
  static int64_t asrl1(int64_t x) { return x &gt;&gt; 1; }
  static int64_t asrl63(int64_t x) { return x &gt;&gt; 63; }
  
  void opi(void)
  {
      int x = 1000;
      pll(addip0(x));
      pll(sublp0(x));
      pll(addip123(x));
      pll(addlm123(x));
      pll(sublp4095(x));
      pll(subim503808(x));
      pll(addp12345(x));
      pll(subp12345(x));
      pll(mvni(x));
      pll(negl(x));
      pll(rsbi123(x));
      pll(rsbl123(x));
      pll(andi0(x));
      pll(andlm1(x));
      pll(orrl0(x));
      pll(orrim1(x));
      pll(eori0(x));
      pll(eorlm1(x));
      pll(and0xf0(x));
      pll(orr0xf0(x));
      pll(eor0xf0(x));
      pll(lsli0(x));
      pll(lsri0(x));
      pll(asrl0(x));
      pll(lsli1(x));
      pll(lsli31(x));
      pll(lsll1(x));
      pll(lsll63(x));
      pll(lsri1(x));
      pll(lsri31(x));
      pll(lsrl1(x));
      pll(lsrl63(x));
      pll(asri1(x));
      pll(asri31(x));
      pll(asrl1(x));
      pll(asrl63(x));
  }
  
  void pcs(void)
  {
      arg();
      ret();
      stdarg();
      movi();
      opi();
  }
  
  int main()
  {
      pcs();
      return 0;
  }
  +9cc ./tests/single-exec/00204.c
  error at ./tests/single-exec/00204.c:4:10
  
  #include &lt;stdarg.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00205.c
  #include &lt;stdio.h&gt;
  
  /* This test is a snippet from the J interpreter */
  
  typedef long I;
  typedef struct{I c[4];I b,e,k;} PT;
  
  PT cases[] = {
   ((I)4194304L +(I)2097152L +(I)67108864L), (I)262144L, (((I)1L +(I)256L +(I)4L +(I)8L +(I)16L +(I)64L +(I)128L +(I)268435456L +(I)536870912L +(I)1024L +(I)4096L +(I)8192L +(I)16384L)+((I)2L +(I)131072L +(I)2048L)+(I)32L +(I)32768L +(I)65536L), -1L, 1,2,1,
   ((I)+4194304L +(I)2097152L +(I)67108864L)+( (I)524288L +(I)262144L +(((I)1L +(I)256L +(I)4L +(I)8L +(I)16L +(I)64L +(I)128L +(I)268435456L +(I)536870912L +(I)1024L +(I)4096L +(I)8192L +(I)16384L)+((I)2L +(I)131072L +(I)2048L)+(I)32L +(I)32768L +(I)65536L)), (I)262144L, (I)262144L, (((I)1L +(I)256L +(I)4L +(I)8L +(I)16L +(I)64L +(I)128L +(I)268435456L +(I)536870912L +(I)1024L +(I)4096L +(I)8192L +(I)16384L)+((I)2L +(I)131072L +(I)2048L)+(I)32L +(I)32768L +(I)65536L), 2,3,2,
   ((I)4194304L +(I)2097152L +(I)67108864L)+( (I)524288L +(I)262144L +(((I)1L +(I)256L +(I)4L +(I)8L +(I)16L +(I)64L +(I)128L +(I)268435456L +(I)536870912L +(I)1024L +(I)4096L +(I)8192L +(I)16384L)+((I)2L +(I)131072L +(I)2048L)+(I)32L +(I)32768L +(I)65536L)), (((I)1L +(I)256L +(I)4L +(I)8L +(I)16L +(I)64L +(I)128L +(I)268435456L +(I)536870912L +(I)1024L +(I)4096L +(I)8192L +(I)16384L)+((I)2L +(I)131072L +(I)2048L)+(I)32L +(I)32768L +(I)65536L), (I)262144L, (((I)1L +(I)256L +(I)4L +(I)8L +(I)16L +(I)64L +(I)128L +(I)268435456L +(I)536870912L +(I)1024L +(I)4096L +(I)8192L +(I)16384L)+((I)2L +(I)131072L +(I)2048L)+(I)32L +(I)32768L +(I)65536L), 1,3,2,
   ((I)4194304L +(I)2097152L +(I)67108864L)+( (I)524288L +(I)262144L +(((I)1L +(I)256L +(I)4L +(I)8L +(I)16L +(I)64L +(I)128L +(I)268435456L +(I)536870912L +(I)1024L +(I)4096L +(I)8192L +(I)16384L)+((I)2L +(I)131072L +(I)2048L)+(I)32L +(I)32768L +(I)65536L)), (I)262144L +(((I)1L +(I)256L +(I)4L +(I)8L +(I)16L +(I)64L +(I)128L +(I)268435456L +(I)536870912L +(I)1024L +(I)4096L +(I)8192L +(I)16384L)+((I)2L +(I)131072L +(I)2048L)+(I)32L +(I)32768L +(I)65536L), (I)524288L, -1L, 1,2,1,
   ((I)4194304L +(I)2097152L +(I)67108864L)+( (I)524288L +(I)262144L +(((I)1L +(I)256L +(I)4L +(I)8L +(I)16L +(I)64L +(I)128L +(I)268435456L +(I)536870912L +(I)1024L +(I)4096L +(I)8192L +(I)16384L)+((I)2L +(I)131072L +(I)2048L)+(I)32L +(I)32768L +(I)65536L)), (I)262144L +(((I)1L +(I)256L +(I)4L +(I)8L +(I)16L +(I)64L +(I)128L +(I)268435456L +(I)536870912L +(I)1024L +(I)4096L +(I)8192L +(I)16384L)+((I)2L +(I)131072L +(I)2048L)+(I)32L +(I)32768L +(I)65536L), (I)1048576L, (I)262144L +(((I)1L +(I)256L +(I)4L +(I)8L +(I)16L +(I)64L +(I)128L +(I)268435456L +(I)536870912L +(I)1024L +(I)4096L +(I)8192L +(I)16384L)+((I)2L +(I)131072L +(I)2048L)+(I)32L +(I)32768L +(I)65536L), 1,3,1,
   ((I)4194304L +(I)2097152L +(I)67108864L)+( (I)524288L +(I)262144L +(((I)1L +(I)256L +(I)4L +(I)8L +(I)16L +(I)64L +(I)128L +(I)268435456L +(I)536870912L +(I)1024L +(I)4096L +(I)8192L +(I)16384L)+((I)2L +(I)131072L +(I)2048L)+(I)32L +(I)32768L +(I)65536L)), (I)262144L +(((I)1L +(I)256L +(I)4L +(I)8L +(I)16L +(I)64L +(I)128L +(I)268435456L +(I)536870912L +(I)1024L +(I)4096L +(I)8192L +(I)16384L)+((I)2L +(I)131072L +(I)2048L)+(I)32L +(I)32768L +(I)65536L), (I)262144L, (I)262144L, 1,3,1,
   ((I)4194304L +(I)2097152L +(I)67108864L), ((I)1048576L +(I)524288L +(I)262144L +(((I)1L +(I)256L +(I)4L +(I)8L +(I)16L +(I)64L +(I)128L +(I)268435456L +(I)536870912L +(I)1024L +(I)4096L +(I)8192L +(I)16384L)+((I)2L +(I)131072L +(I)2048L)+(I)32L +(I)32768L +(I)65536L)), ((I)1048576L +(I)524288L +(I)262144L +(((I)1L +(I)256L +(I)4L +(I)8L +(I)16L +(I)64L +(I)128L +(I)268435456L +(I)536870912L +(I)1024L +(I)4096L +(I)8192L +(I)16384L)+((I)2L +(I)131072L +(I)2048L)+(I)32L +(I)32768L +(I)65536L)), -1L, 1,2,1,
   (I)33554432L +(((I)1L +(I)256L +(I)4L +(I)8L +(I)16L +(I)64L +(I)128L +(I)268435456L +(I)536870912L +(I)1024L +(I)4096L +(I)8192L +(I)16384L)+((I)2L +(I)131072L +(I)2048L)+(I)32L +(I)32768L +(I)65536L), (I)2097152L, ((I)1048576L +(I)524288L +(I)262144L +(((I)1L +(I)256L +(I)4L +(I)8L +(I)16L +(I)64L +(I)128L +(I)268435456L +(I)536870912L +(I)1024L +(I)4096L +(I)8192L +(I)16384L)+((I)2L +(I)131072L +(I)2048L)+(I)32L +(I)32768L +(I)65536L)), -1L, 0,2,1,
   (I)67108864L, ((I)1048576L +(I)524288L +(I)262144L +(((I)1L +(I)256L +(I)4L +(I)8L +(I)16L +(I)64L +(I)128L +(I)268435456L +(I)536870912L +(I)1024L +(I)4096L +(I)8192L +(I)16384L)+((I)2L +(I)131072L +(I)2048L)+(I)32L +(I)32768L +(I)65536L)), (I)134217728L, -1L, 0,2,0,
  };
  
  int main() {
      int i, j;
  
      for(j=0; j &lt; sizeof(cases)/sizeof(cases[0]); j++) {
  	for(i=0; i &lt; sizeof(cases-&gt;c)/sizeof(cases-&gt;c[0]); i++)
  	    printf(&quot;cases[%d].c[%d]=%ld\n&quot;, j, i, cases[j].c[i]);
  
  	printf(&quot;cases[%d].b=%ld\n&quot;, j, cases[j].b);
  	printf(&quot;cases[%d].e=%ld\n&quot;, j, cases[j].e);
  	printf(&quot;cases[%d].k=%ld\n&quot;, j, cases[j].k);
  	printf(&quot;\n&quot;);
      }
      return 0;
  }
  +9cc ./tests/single-exec/00205.c
  error at ./tests/single-exec/00205.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00206.c
  #include &lt;stdio.h&gt;
  
  int main()
  {
      /* must not affect how #pragma ppop_macro works */
      #define pop_macro foobar1
  
      /* must not affect how #pragma push_macro works */
      #define push_macro foobar2
  
      #undef abort
      #define abort &quot;111&quot;
      printf(&quot;abort = %s\n&quot;, abort);
  
      #pragma push_macro(&quot;abort&quot;)
      #undef abort
      #define abort &quot;222&quot;
      printf(&quot;abort = %s\n&quot;, abort);
  
      #pragma push_macro(&quot;abort&quot;)
      #undef abort
      #define abort &quot;333&quot;
      printf(&quot;abort = %s\n&quot;, abort);
  
      #pragma pop_macro(&quot;abort&quot;)
      printf(&quot;abort = %s\n&quot;, abort);
  
      #pragma pop_macro(&quot;abort&quot;)
      printf(&quot;abort = %s\n&quot;, abort);
  }
  +9cc ./tests/single-exec/00206.c
  error at ./tests/single-exec/00206.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00207.c
  #include &lt;stdio.h&gt;
  
  /* This test segfaults as of April 27, 2015. */
  void f1(int argc)
  {
    char test[argc];
    if(0)
    label:
      printf(&quot;boom!\n&quot;);
    if(argc-- == 0)
      return;
    goto label;
  }
  
  /* This segfaulted on 2015-11-19. */
  void f2(void)
  {
      goto start;
      {
          int a[1 &amp;&amp; 1]; /* not a variable-length array */
          int b[1 || 1]; /* not a variable-length array */
          int c[1 ? 1 : 1]; /* not a variable-length array */
      start:
          a[0] = 0;
          b[0] = 0;
          c[0] = 0;
      }
  }
  
  void f3(void)
  {
      printf(&quot;%d\n&quot;, 0 ? printf(&quot;x1\n&quot;) : 11);
      printf(&quot;%d\n&quot;, 1 ? 12 : printf(&quot;x2\n&quot;));
      printf(&quot;%d\n&quot;, 0 &amp;&amp; printf(&quot;x3\n&quot;));
      printf(&quot;%d\n&quot;, 1 || printf(&quot;x4\n&quot;));
  }
  
  int main()
  {
    f1(2);
    f2();
    f3();
  
    return 0;
  }
  +9cc ./tests/single-exec/00207.c
  error at ./tests/single-exec/00207.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00208.c
  #include &lt;stdio.h&gt;
  struct wchar {
      char *data; char mem[];
  };
  struct wint {
      char *data; int mem[];
  };
  int f1char (void) {
      char s[9]=&quot;nonono&quot;;
      struct wchar q = {&quot;bugs&quot;};
      return !s[0];
  }
  int f1int (void) {
      char s[9]=&quot;nonono&quot;;
      struct wint q = {&quot;bugs&quot;};
      return !s[0];
  }
  int main (void) {
     char s[9]=&quot;nonono&quot;;
     static struct wchar q = {&quot;bugs&quot;, {&#x27;c&#x27;}};
     //printf (&quot;tcc has %s %s\n&quot;, s, q.data);
     if (f1char() || f1int())
       printf (&quot;bla\n&quot;);
     return !s[0];
  }
  +9cc ./tests/single-exec/00208.c
  error at ./tests/single-exec/00208.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00209.c
  /* The following are all valid decls, even though some subtypes
     are incomplete.  */
  enum E *e;
  const enum E *e1;
  enum E const *e2;
  struct S *s;
  const struct S *s1;
  struct S const *s2;
  
  /* Various strangely looking declarators, which are all valid
     and have to map to the same numbered typedefs. */
  typedef int (*fptr1)();
  int f1 (int (), int);
  typedef int (*fptr2)(int x);
  int f2 (int (int x), int);
  typedef int (*fptr3)(int);
  int f3 (int (int), int);
  typedef int (*fptr4[4])(int);
  int f4 (int (*[4])(int), int);
  typedef int (*fptr5)(fptr1);
  int f5 (int (int()), fptr1);
  int f1 (fptr1 fp, int i)
  {
    return (*fp)(i);
  }
  int f2 (fptr2 fp, int i)
  {
    return (*fp)(i);
  }
  int f3 (fptr3 fp, int i)
  {
    return (*fp)(i);
  }
  int f4 (fptr4 fp, int i)
  {
    return (*fp[i])(i);
  }
  int f5 (fptr5 fp, fptr1 i)
  {
    return fp(i);
  }
  int f8 (int ([4]), int);
  int main () { return 0; }
  +9cc ./tests/single-exec/00209.c
  error at ./tests/single-exec/00209.c:3:6
  
  enum E *e;
       ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00210.c
  typedef unsigned short uint16_t;
  typedef unsigned char uint8_t;
  
  typedef union Unaligned16a {
    uint16_t u;
    uint8_t b[2];
  } __attribute__((packed)) Unaligned16a;
  
  typedef union __attribute__((packed)) Unaligned16b {
    uint16_t u;
    uint8_t b[2];
  } Unaligned16b;
  
  extern void foo (void) __attribute__((stdcall));
  void __attribute__((stdcall)) foo (void)
  {
  }
  
  /* The actual attribute isn&#x27;t important, must just be
     parsable.  */
  #define ATTR __attribute__((__noinline__))
  int ATTR actual_function() {
    return 42;
  }
  
  extern int printf (const char *, ...);
  int main()
  {
      void *function_pointer = &amp;actual_function;
  
      int a = ((ATTR int(*) (void)) function_pointer)();
      printf(&quot;%i\n&quot;, a);
  
      /* In the following we once misparsed &#x27;ATTR *&#x27; is a btype
         and hence the whole type was garbled.  */
      int b = ( (int(ATTR *)(void))  function_pointer)();
      printf(&quot;%i\n&quot;, b);
  
      return 0;
  }
  +9cc ./tests/single-exec/00210.c
  error at ./tests/single-exec/00210.c:1:18
  
  typedef unsigned short uint16_t;
                   ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00211.c
  extern int printf(const char *format, ...);
  
  #define ACPI_TYPE_INVALID       0x1E
  #define NUM_NS_TYPES            ACPI_TYPE_INVALID+1
  int array[NUM_NS_TYPES];
  
  #define n 0xe
  int main()
  {
      printf(&quot;n+1 = %d\n&quot;, n+1);
  //    printf(&quot;n+1 = %d\n&quot;, 0xe+1);
  }
  +9cc ./tests/single-exec/00211.c
  Segmentation fault (core dumped)
  +exit 1
not ok ./tests/single-exec/00212.c
  #include &lt;stdio.h&gt;
  
  int
  main()
  {
  #if defined(__LLP64__)
  	if (sizeof(short) == 2
  	    &amp;&amp; sizeof(int) == 4
  	    &amp;&amp; sizeof(long int) == 4
  	    &amp;&amp; sizeof(long long int) == 8
  	    &amp;&amp; sizeof(void*) == 8) {
  		(void)printf(&quot;Ok\n&quot;);
  	} else {
  		(void)printf(&quot;KO __LLP64__\n&quot;);
  	}
  #elif defined(__LP64__)
  	if (sizeof(short) == 2
  	    &amp;&amp; sizeof(int) == 4
  	    &amp;&amp; sizeof(long int) == 8
  	    &amp;&amp; sizeof(long long int) == 8
  	    &amp;&amp; sizeof(void*) == 8) {
  		(void)printf(&quot;Ok\n&quot;);
  	} else {
  		(void)printf(&quot;KO __LP64__\n&quot;);
  	}
  #elif defined(__ILP32__)
  	if (sizeof(short) == 2
  	    &amp;&amp; sizeof(int) == 4
  	    &amp;&amp; sizeof(long int) == 4
  	    &amp;&amp; sizeof(void*) == 4) {
  		(void)printf(&quot;Ok\n&quot;);
  	} else {
  		(void)printf(&quot;KO __ILP32__\n&quot;);
  	}
  #else
  	(void)printf(&quot;KO no __*LP*__ defined.\n&quot;);
  #endif
  }
  +9cc ./tests/single-exec/00212.c
  error at ./tests/single-exec/00212.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00213.c
  /* This checks various ways of dead code inside if statements
     where there are non-obvious ways of how the code is actually
     not dead due to reachable by labels.  */
  extern int printf (const char *, ...);
  static void kb_wait_1(void)
  {
    unsigned long timeout = 2;
    do {
        /* Here the else arm is a statement expression that&#x27;s supposed
           to be suppressed.  The label inside the while would unsuppress
  	 code generation again if not handled correctly.  And that
  	 would wreak havoc to the cond-expression because there&#x27;s no
  	 jump-around emitted, the whole statement expression really
  	 needs to not generate code (perhaps except useless forward jumps).  */
        (1 ? 
         printf(&quot;timeout=%ld\n&quot;, timeout) :
         ({
  	int i = 1;
  	while (1)
  	  while (i--)
  	    some_label:
  	      printf(&quot;error\n&quot;);
  	goto some_label;
  	})
        );
        timeout--;
    } while (timeout);
  }
  
  static int global;
  
  static void foo(int i)
  {
    global+=i;
    printf (&quot;g=%d\n&quot;, global);
  }
  
  static int check(void)
  {
    printf (&quot;check %d\n&quot;, global);
    return 1;
  }
  
  static void dowhile(void)
  {
    do {
        foo(1);
        if (global == 1) {
  	  continue;
        } else if (global == 2) {
  	  continue;
        }
        /* The following break shouldn&#x27;t disable the check() call,
           as it&#x27;s reachable by the continues above.  */
        break;
    } while (check());
  }
  
  int main (void)
  {
    int i = 1;
    kb_wait_1();
  
    /* Simple test of dead code at first sight which isn&#x27;t actually dead. */
    if (0) {
  yeah:
        printf (&quot;yeah\n&quot;);
    } else {
        printf (&quot;boo\n&quot;);
    }
    if (i--)
      goto yeah;
  
    /* Some more non-obvious uses where the problems are loops, so that even
       the first loop statements aren&#x27;t actually dead.  */
    i = 1;
    if (0) {
        while (i--) {
  	  printf (&quot;once\n&quot;);
  enterloop:
  	  printf (&quot;twice\n&quot;);
        }
    }
    if (i &gt;= 0)
      goto enterloop;
  
    /* The same with statement expressions.  One might be tempted to
       handle them specially by counting if inside statement exprs and
       not unsuppressing code at loops at all then.
       See kb_wait_1 for the other side of the medal where that wouldn&#x27;t work.  */
    i = ({
        int j = 1;
        if (0) {
  	  while (j--) {
  	      printf (&quot;SEonce\n&quot;);
      enterexprloop:
  	      printf (&quot;SEtwice\n&quot;);
  	  }
        }
        if (j &gt;= 0)
  	goto enterexprloop;
        j; });
  
    /* The other two loop forms: */
    i = 1;
    if (0) {
        for (i = 1; i--;) {
  	  printf (&quot;once2\n&quot;);
  enterloop2:
  	  printf (&quot;twice2\n&quot;);
        }
    }
    if (i &gt; 0)
      goto enterloop2;
  
    i = 1;
    if (0) {
        do {
  	  printf (&quot;once3\n&quot;);
  enterloop3:
  	  printf (&quot;twice3\n&quot;);
        } while (i--);
    }
    if (i &gt; 0)
      goto enterloop3;
  
    /* And check that case and default labels have the same effect
       of disabling code suppression.  */
    i = 41;
    switch (i) {
        if (0) {
  	  printf (&quot;error\n&quot;);
        case 42:
  	  printf (&quot;error2\n&quot;);
        case 41:
  	  printf (&quot;caseok\n&quot;);
        }
    }
  
    i = 41;
    switch (i) {
        if (0) {
  	  printf (&quot;error3\n&quot;);
        default:
  	  printf (&quot;caseok2\n&quot;);
  	  break;
        case 42:
  	  printf (&quot;error4\n&quot;);
        }
    }
  
    dowhile();
  
    return 0;
  }
  +9cc ./tests/single-exec/00213.c
  Segmentation fault (core dumped)
  +exit 1
not ok ./tests/single-exec/00214.c
  /* Check some way in where code suppression caused various
     miscompilations.  */
  extern int printf (const char *, ...);
  typedef unsigned long size_t;
  
  size_t _brk_start, _brk_end;
  void * extend_brk(size_t size, size_t align)
  {
      size_t mask = align - 1;
      void *ret = 0;
  
       do {
  	 if (__builtin_expect(!!(_brk_start == 0), 0))
  	   do {
  	       printf(&quot;wrong1\n&quot;);
  	   } while (0);
       } while (0);
       _brk_end = (_brk_end + mask) &amp; ~mask;
       ret = (void *)_brk_end;
       _brk_end += size;
  
       return ret;
  }
  
  static void get_args (int a, int b)
  {
    if (a != 1)
      printf(&quot;wrong2\n&quot;);
    else
      printf(&quot;okay\n&quot;);
  }
  
  void bla(void)
  {
    int __ret = 42;
    ({
      if (__builtin_expect(!!(0), 0)) {
        if (__builtin_expect(!!__ret, 0))
          printf(&quot;wrong3\n&quot;);
        int x = !!(__ret);
      }
      __ret;
    });
    get_args(!!__ret, sizeof(__ret));
  }
  
  _Bool chk(unsigned long addr, unsigned long limit, unsigned long size)
  {
    _Bool ret;
    /* This just needs to compile, no runtime test.  (And it doesn&#x27;t compile
       only with certain internal checking added that&#x27;s not committed).  */
    if (0)
      ret = 0 != (!!(addr &gt; limit - size));
  }
  
  int main()
  {
    void *r;
    _brk_start = 1024;
    _brk_end = 1024;
    r = extend_brk (4096, 16);
    if (!r)
      printf(&quot;wrong4\n&quot;);
    else
      printf(&quot;okay\n&quot;);
    bla();
    return 0;
  }
  +9cc ./tests/single-exec/00214.c
  Segmentation fault (core dumped)
  +exit 1
not ok ./tests/single-exec/00215.c
  extern int printf(const char *format, ...);
  static void kb_wait_1(void)
  {
      unsigned long timeout = 2;
      do {
          (1 ?
              printf(&quot;timeout=%ld\n&quot;, timeout) :
              ({
                  while (1)
                      printf(&quot;error\n&quot;);
              })
          );
          timeout--;
      } while (timeout);
  }
  static void kb_wait_2(void)
  {
      unsigned long timeout = 2;
      do {
          (1 ?
              printf(&quot;timeout=%ld\n&quot;, timeout) :
              ({
                  for (;;)
                      printf(&quot;error\n&quot;);
              })
          );
          timeout--;
      } while (timeout);
  }
  static void kb_wait_2_1(void)
  {
      unsigned long timeout = 2;
      do {
          (1 ?
              printf(&quot;timeout=%ld\n&quot;, timeout) :
              ({
                  do {
                      printf(&quot;error\n&quot;);
  		} while (1);
              })
          );
          timeout--;
      } while (timeout);
  }
  static void kb_wait_2_2(void)
  {
      unsigned long timeout = 2;
      do {
          (1 ?
              printf(&quot;timeout=%ld\n&quot;, timeout) :
              ({
                  label:
                      printf(&quot;error\n&quot;);
  		goto label;
              })
          );
          timeout--;
      } while (timeout);
  }
  static void kb_wait_3(void)
  {
      unsigned long timeout = 2;
      do {
          (1 ?
              printf(&quot;timeout=%ld\n&quot;, timeout) :
              ({
                  int i = 1;
                  goto label;
                  i = i + 2;
              label:
                  i = i + 3;
              })
          );
          timeout--;
      } while (timeout);
  }
  static void kb_wait_4(void)
  {
      unsigned long timeout = 2;
      do {
          (1 ?
              printf(&quot;timeout=%ld\n&quot;, timeout) :
              ({
                  switch(timeout) {
                      case 2:
                          printf(&quot;timeout is 2&quot;);
                          break;
                      case 1:
                          printf(&quot;timeout is 1&quot;);
                          break;
                      default:
                          printf(&quot;timeout is 0?&quot;);
                          break;
                  };
                  // return;
              })
          );
          timeout--;
      } while (timeout);
  }
  int main()
  {
      printf(&quot;begin\n&quot;);
      kb_wait_1();
      kb_wait_2();
      kb_wait_2_1();
      kb_wait_2_2();
      kb_wait_3();
      kb_wait_4();
      printf(&quot;end\n&quot;);
      return 0;
  }
  +9cc ./tests/single-exec/00215.c
  Segmentation fault (core dumped)
  +exit 1
not ok ./tests/single-exec/00216.c
  typedef unsigned char u8;
  typedef struct {} empty_s;
  struct contains_empty {
      u8 a;
      empty_s empty;
      u8 b;
  };
  struct contains_empty ce = { { (1) }, (empty_s){}, 022, };
  /* The following decl of &#x27;q&#x27; would demonstrate the TCC bug in init_putv when
     handling copying compound literals.  (Compound literals
     aren&#x27;t acceptable constant initializers in isoc99, but
     we accept them like gcc, except for this case)
  //char *q = (char *){ &quot;trara&quot; }; */
  struct SS {u8 a[3], b; };
  struct SS sinit16[] = { { 1 }, 2 };
  struct S
  {
    u8 a,b;
    u8 c[2];
  };
  
  struct T
  {
    u8 s[16];
    u8 a;
  };
  
  struct U
  {
    u8 a;
    struct S s;
    u8 b;
    struct T t;
  };
  
  struct V
  {
    struct S s;
    struct T t;
    u8 a;
  };
  
  struct W
  {
    struct V t;
    struct S s[];
  };
  
  struct S gs = ((struct S){1, 2, 3, 4});
  struct S gs2 = {1, 2, {3, 4}};
  struct T gt = {&quot;hello&quot;, 42};
  struct U gu = {3, 5,6,7,8, 4, &quot;huhu&quot;, 43};
  struct U gu2 = {3, {5,6,7,8}, 4, {&quot;huhu&quot;, 43}};
  /* Optional braces around scalar initializers.  Accepted, but with
     a warning.  */
  struct U gu3 = { {3}, {5,6,7,8,}, 4, {&quot;huhu&quot;, 43}};
  /* Many superfluous braces and leaving out one initializer for U.s.c[1] */
  struct U gu4 = { 3, {5,6,7,},  5, { &quot;bla&quot;, {44}} };
  /* Superfluous braces and useless parens around values */
  struct S gs3 = { (1), {(2)}, {(((3))), {4}}};
  /* Superfluous braces, and leaving out braces for V.t, plus cast */
  struct V gv = {{{3},4,{5,6}}, &quot;haha&quot;, (u8)45, 46};
  /* Compound literal */
  struct V gv2 = {(struct S){7,8,{9,10}}, {&quot;hihi&quot;, 47}, 48};
  /* Parens around compound literal */
  struct V gv3 = {((struct S){7,8,{9,10}}), {&quot;hoho&quot;, 49}, 50};
  /* Initialization of a flex array member (warns in GCC) */
  struct W gw = {{1,2,3,4}, {1,2,3,4,5}};
  
  union UU {
      u8 a;
      u8 b;
  };
  struct SU {
      union UU u;
      u8 c;
  };
  struct SU gsu = {5,6};
  
  /* Unnamed struct/union members aren&#x27;t ISO C, but it&#x27;s a widely accepted
     extension.  See below for further extensions to that under -fms-extension.*/
  union UV {
      struct {u8 a,b;};
      struct S s;
  };
  union UV guv = {{6,5}};
  union UV guv2 = {{.b = 7, .a = 8}};
  union UV guv3 = {.b = 8, .a = 7};
  
  /* Under -fms-extensions also the following is valid:
  union UV2 {
      struct Anon {u8 a,b;};    // unnamed member, but tagged struct, ...
      struct S s;
  };
  struct Anon gan = { 10, 11 }; // ... which makes it available here.
  union UV2 guv4 = {{4,3}};     // and the other inits from above as well
  */
  
  struct in6_addr {
      union {
  	u8 u6_addr8[16];
  	unsigned short u6_addr16[8];
      } u;
  };
  struct flowi6 {
      struct in6_addr saddr, daddr;
  };
  struct pkthdr {
      struct in6_addr daddr, saddr;
  };
  struct pkthdr phdr = { { { 6,5,4,3 } }, { { 9,8,7,6 } } };
  
  struct Wrap {
      void *func;
  };
  int global;
  void inc_global (void)
  {
    global++;
  }
  
  struct Wrap global_wrap[] = {
      ((struct Wrap) {inc_global}),
      inc_global,
  };
  
  #include &lt;stdio.h&gt;
  void print_ (const char *name, const u8 *p, long size)
  {
    printf (&quot;%s:&quot;, name);
    while (size--) {
        printf (&quot; %x&quot;, *p++);
    }
    printf (&quot;\n&quot;);
  }
  #define print(x) print_(#x, (u8*)&amp;x, sizeof (x))
  #if 1
  void foo (struct W *w, struct pkthdr *phdr_)
  {
    struct S ls = {1, 2, 3, 4};
    struct S ls2 = {1, 2, {3, 4}};
    struct T lt = {&quot;hello&quot;, 42};
    struct U lu = {3, 5,6,7,8, 4, &quot;huhu&quot;, 43};
    struct U lu1 = {3, ls, 4, {&quot;huhu&quot;, 43}};
    struct U lu2 = {3, (ls), 4, {&quot;huhu&quot;, 43}};
    const struct S *pls = &amp;ls;
    struct S ls21 = *pls;
    struct U lu22 = {3, *pls, 4, {&quot;huhu&quot;, 43}};
    /* Incomplete bracing.  */
    struct U lu21 = {3, ls, 4, &quot;huhu&quot;, 43};
    /* Optional braces around scalar initializers.  Accepted, but with
       a warning.  */
    struct U lu3 = { 3, {5,6,7,8,}, 4, {&quot;huhu&quot;, 43}};
    /* Many superfluous braces and leaving out one initializer for U.s.c[1] */
    struct U lu4 = { 3, {5,6,7,},  5, { &quot;bla&quot;, 44} };
    /* Superfluous braces and useless parens around values */
    struct S ls3 = { (1), (2), {(((3))), 4}};
    /* Superfluous braces, and leaving out braces for V.t, plus cast */
    struct V lv = {{3,4,{5,6}}, &quot;haha&quot;, (u8)45, 46};
    /* Compound literal */
    struct V lv2 = {(struct S)w-&gt;t.s, {&quot;hihi&quot;, 47}, 48};
    /* Parens around compound literal */
    struct V lv3 = {((struct S){7,8,{9,10}}), ((const struct W *)w)-&gt;t.t, 50};
    const struct pkthdr *phdr = phdr_;
    struct flowi6 flow = { .daddr = phdr-&gt;daddr, .saddr = phdr-&gt;saddr };
    int elt = 0x42;
    /* Range init, overlapping */
    struct T lt2 = { { [1 ... 5] = 9, [6 ... 10] = elt, [4 ... 7] = elt+1 }, 1 };
    print(ls);
    print(ls2);
    print(lt);
    print(lu);
    print(lu1);
    print(lu2);
    print(ls21);
    print(lu21);
    print(lu22);
    print(lu3);
    print(lu4);
    print(ls3);
    print(lv);
    print(lv2);
    print(lv3);
    print(lt2);
    print(flow);
  }
  #endif
  
  void test_compound_with_relocs (void)
  {
    struct Wrap local_wrap[] = {
        ((struct Wrap) {inc_global}),
        inc_global,
    };
    void (*p)(void);
    p = global_wrap[0].func; p();
    p = global_wrap[1].func; p();
    p = local_wrap[0].func; p();
    p = local_wrap[1].func; p();
  }
  
  void sys_ni(void) { printf(&quot;ni\n&quot;); }
  void sys_one(void) { printf(&quot;one\n&quot;); }
  void sys_two(void) { printf(&quot;two\n&quot;); }
  void sys_three(void) { printf(&quot;three\n&quot;); }
  typedef void (*fptr)(void);
  const fptr table[3] = {
      [0 ... 2] = &amp;sys_ni,
      [0] = sys_one,
      [1] = sys_two,
      [2] = sys_three,
  };
  
  void test_multi_relocs(void)
  {
    int i;
    for (i = 0; i &lt; sizeof(table)/sizeof(table[0]); i++)
      table[i]();
  }
  
  /* Following is from GCC gcc.c-torture/execute/20050613-1.c.  */
  
  struct SEA { int i; int j; int k; int l; };
  struct SEB { struct SEA a; int r[1]; };
  struct SEC { struct SEA a; int r[0]; };
  struct SED { struct SEA a; int r[]; };
  
  static void
  test_correct_filling (struct SEA *x)
  {
    static int i;
    if (x-&gt;i != 0 || x-&gt;j != 5 || x-&gt;k != 0 || x-&gt;l != 0)
      printf(&quot;sea_fill%d: wrong\n&quot;, i);
    else
      printf(&quot;sea_fill%d: okay\n&quot;, i);
    i++;
  }
  
  int
  test_zero_init (void)
  {
    /* The peculiarity here is that only a.j is initialized.  That
       means that all other members must be zero initialized.  TCC
       once didn&#x27;t do that for sub-level designators.  */
    struct SEB b = { .a.j = 5 };
    struct SEC c = { .a.j = 5 };
    struct SED d = { .a.j = 5 };
    test_correct_filling (&amp;b.a);
    test_correct_filling (&amp;c.a);
    test_correct_filling (&amp;d.a);
    return 0;
  }
  
  int main()
  {
    print(ce);
    print(gs);
    print(gs2);
    print(gt);
    print(gu);
    print(gu2);
    print(gu3);
    print(gu4);
    print(gs3);
    print(gv);
    print(gv2);
    print(gv3);
    print(sinit16);
    print(gw);
    print(gsu);
    print(guv);
    print(guv.b);
    print(guv2);
    print(guv3);
    print(phdr);
    foo(&amp;gw, &amp;phdr);
    //printf(&quot;q: %s\n&quot;, q);
    test_compound_with_relocs();
    test_multi_relocs();
    test_zero_init();
    return 0;
  }
  +9cc ./tests/single-exec/00216.c
  error at ./tests/single-exec/00216.c:127:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00217.c
  int printf(const char *, ...);
  char t[] = &quot;012345678&quot;;
  
  int main(void)
  {
      char *data = t;
      unsigned long long r = 4;
      unsigned a = 5;
      unsigned long long b = 12;
  
      *(unsigned*)(data + r) += a - b;
  
      printf(&quot;data = \&quot;%s\&quot;\n&quot;, data);
      return 0;
  }
  +9cc ./tests/single-exec/00217.c
  Segmentation fault (core dumped)
  +exit 1
not ok ./tests/single-exec/00218.c
  /* This checks if enums needing 8 bit but only having positive
     values are correctly zero extended (instead of sign extended)
     when stored into/loaded from a 8 bit bit-field of enum type (which
     itself is implementation defined, so isn&#x27;t necessarily supported by all
     other compilers).  */
  enum tree_code {
    SOME_CODE = 148, /* has bit 7 set, and hence all further enum values as well */
    LAST_AND_UNUSED_TREE_CODE
  };
  typedef union tree_node *tree;
  struct tree_common
  {
    union tree_node *chain;
    union tree_node *type;
    enum tree_code code : 8;
    unsigned side_effects_flag : 1;
  };
  union tree_node
  {
    struct tree_common common;
   };
  enum c_tree_code {
    C_DUMMY_TREE_CODE = LAST_AND_UNUSED_TREE_CODE,
    STMT_EXPR,
    LAST_C_TREE_CODE
  };
  enum cplus_tree_code {
    CP_DUMMY_TREE_CODE = LAST_C_TREE_CODE,
    AMBIG_CONV,
    LAST_CPLUS_TREE_CODE
  };
  
  extern int printf(const char *, ...);
  int blah(){return 0;}
  
  int convert_like_real (tree convs)
  {
    switch (((enum tree_code) (convs)-&gt;common.code))
      {
      case AMBIG_CONV: /* This has bit 7 set, which must not be the sign
  			bit in tree_common.code, i.e. the bitfield must
  			be somehow marked unsigned.  */
        return blah();
      default:
        break;
      };
     printf(&quot;unsigned enum bit-fields broken\n&quot;);
  }
  
  int main()
  {
    union tree_node convs;
  
    convs.common.code = AMBIG_CONV;
    convert_like_real (&amp;convs);
    return 0;
  }
  +9cc ./tests/single-exec/00218.c
  error at ./tests/single-exec/00218.c:6:6
  
  enum tree_code {
       ^
  
  ; expected
  +exit 1
not ok ./tests/single-exec/00219.c
  #include &lt;stdio.h&gt;
  
  const int a = 0;
  
  struct a {
  	int a;
  };
  
  struct b {
  	int a;
  };
  
  int a_f()
  {
  	return 20;
  }
  
  int b_f()
  {
  	return 10;
  }
  
  typedef int (*fptr)(int);
  int foo(int i)
  {
    return i;
  }
  
  typedef int int_type1;
  
  #define gen_sw(a) _Generic(a, const char *: 1, default: 8, int: 123);
  
  int main()
  {
  	int i = 0;
  	signed long int l = 2;
  	struct b titi;
  	const int * const ptr;
  	const char *ti;
  	int_type1 i2;
  
  	i = _Generic(a, int: a_f, const int: b_f)();
  	printf(&quot;%d\n&quot;, i);
  	i = _Generic(a, int: a_f() / 2, const int: b_f() / 2);
  	printf(&quot;%d\n&quot;, i);
  	i = _Generic(ptr, int *:1, int * const:2, default:20);
  	printf(&quot;%d\n&quot;, i);
  	i = gen_sw(a);
  	printf(&quot;%d\n&quot;, i);
  	i = _Generic(titi, struct a:1, struct b:2, default:20);
  	printf(&quot;%d\n&quot;, i);
  	i = _Generic(i2, char: 1, int : 0);
  	printf(&quot;%d\n&quot;, i);
  	i = _Generic(a, char:1, int[4]:2, default:5);
  	printf(&quot;%d\n&quot;, i);
  	i = _Generic(17, int :1, int **:2);
  	printf(&quot;%d\n&quot;, i);
  	i = _Generic(17L, int :1, long :2, long long : 3);
  	printf(&quot;%d\n&quot;, i);
  	i = _Generic(&quot;17, io&quot;, char *: 3, const char *: 1);
  	printf(&quot;%d\n&quot;, i);
  	i = _Generic(ti, const unsigned char *:1, const char *:4, char *:3,
  		     const signed char *:2);
  	printf(&quot;%d\n&quot;, i);
  	printf(&quot;%s\n&quot;, _Generic(i + 2L, long: &quot;long&quot;, int: &quot;int&quot;,
  				long long: &quot;long long&quot;));
  	i = _Generic(l, long: 1, int: 2);
  	printf(&quot;%d\n&quot;, i);
  	i = _Generic(foo, fptr: 3, int: 4);
  	printf(&quot;%d\n&quot;, i);
  	return 0;
  }
  +9cc ./tests/single-exec/00219.c
  error at ./tests/single-exec/00219.c:1:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
not ok ./tests/single-exec/00220.c
  // this file contains BMP chars encoded in UTF-8
  #include &lt;stdio.h&gt;
  #include &lt;wchar.h&gt;
  
  int main()
  {
      wchar_t s[] = L&quot;hello$$你好¢¢世界€€world&quot;;
      wchar_t *p;
      for (p = s; *p; p++) printf(&quot;%04X &quot;, (unsigned) *p);
      printf(&quot;\n&quot;);
      return 0;
  }
  +9cc ./tests/single-exec/00220.c
  error at ./tests/single-exec/00220.c:2:10
  
  #include &lt;stdio.h&gt;
           ^
  
  string expected
  +exit 1
</pre>
<br>
<a href="/9cc-x86_64-single-exec_report.tap">raw TAP data</a> <a href="/9cc-x86_64-single-exec_report.tap.txt">(.txt)</a>
<br>
    </body>
    </html>
